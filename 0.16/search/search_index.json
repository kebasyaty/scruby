{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scruby","text":"<p> Asynchronous library for building and managing a hybrid database,by scheme of key-value. <p> </p> </p> <p></p> <p>   The library uses fractal-tree addressing and      the search for documents based on the effect of a quantum loop.       The database consists of collections.      The maximum size of the one collection is 16\\*\\*8=4294967296 branches,      each branch can store one or more keys.       The value of any key in collection can be obtained in 8 steps,      thereby achieving high performance.       The effectiveness of the search for documents based on a quantum loop,      requires a large number of processor threads. </p> <p></p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/aggregation/","title":"Aggregation classes","text":"<p>Aggregation classes.</p>"},{"location":"pages/aggregation/#scruby.aggregation.Average","title":"<code>Average</code>","text":"<p>Aggregation class for calculating the average value.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>str</code> <p>The accuracy of rounding. <code>By default = .00</code></p> <code>'.00'</code> <code>rounding</code> <code>str</code> <p>Rounding mode. <code>By default = ROUND_HALF_EVEN</code></p> <code>ROUND_HALF_EVEN</code> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>class Average:\n    \"\"\"Aggregation class for calculating the average value.\n\n    Args:\n        precision: The accuracy of rounding. `By default = .00`\n        rounding: Rounding mode. `By default = ROUND_HALF_EVEN`\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        precision: str = \".00\",\n        rounding: str = ROUND_HALF_EVEN,\n    ) -&gt; None:\n        self.value = Decimal()\n        self.counter = 0\n        self.precision = precision\n        self.rounding = rounding\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value (int | float).\n        \"\"\"\n        self.value += Decimal(str(number))\n        self.counter += 1\n\n    def get(self) -&gt; Decimal:\n        \"\"\"Get arithmetic average value.\n\n        Returns:\n            Number (Decimal) - Average value.\n        \"\"\"\n        return (self.value / Decimal(str(self.counter))).quantize(\n            exp=Decimal(self.precision),\n            rounding=self.rounding,\n        )\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Average.get","title":"<code>get()</code>","text":"<p>Get arithmetic average value.</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>Number (Decimal) - Average value.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def get(self) -&gt; Decimal:\n    \"\"\"Get arithmetic average value.\n\n    Returns:\n        Number (Decimal) - Average value.\n    \"\"\"\n    return (self.value / Decimal(str(self.counter))).quantize(\n        exp=Decimal(self.precision),\n        rounding=self.rounding,\n    )\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Average.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value (int | float).</p> required Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value (int | float).\n    \"\"\"\n    self.value += Decimal(str(number))\n    self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter","title":"<code>Counter</code>","text":"<p>Aggregation class for calculating the number of documents.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum counter value.</p> <code>1000</code> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>class Counter:\n    \"\"\"Aggregation class for calculating the number of documents.\n\n    Args:\n        limit: The maximum counter value.\n    \"\"\"\n\n    def __init__(self, limit: int = 1000) -&gt; None:  # noqa: D107\n        self.limit = limit\n        self.counter = 0\n\n    def check(self) -&gt; bool:\n        \"\"\"Check the condition of the counter.\n\n        Returns:\n            Boolean value. If `True`, the maximum value is achieved.\n        \"\"\"\n        return self.counter &gt;= self.limit\n\n    def next(self) -&gt; None:\n        \"\"\"Increment the counter on one.\"\"\"\n        self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter.check","title":"<code>check()</code>","text":"<p>Check the condition of the counter.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean value. If <code>True</code>, the maximum value is achieved.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def check(self) -&gt; bool:\n    \"\"\"Check the condition of the counter.\n\n    Returns:\n        Boolean value. If `True`, the maximum value is achieved.\n    \"\"\"\n    return self.counter &gt;= self.limit\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter.next","title":"<code>next()</code>","text":"<p>Increment the counter on one.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def next(self) -&gt; None:\n    \"\"\"Increment the counter on one.\"\"\"\n    self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max","title":"<code>Max</code>","text":"<p>Aggregation class for calculating the maximum value.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>class Max:\n    \"\"\"Aggregation class for calculating the maximum value.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value: Any = 0\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        if number &gt; self.value:\n            self.value = number\n\n    def get(self) -&gt; Any:\n        \"\"\"Get maximum value.\n\n        Returns:\n            Number (int|float) - Maximum value.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max.get","title":"<code>get()</code>","text":"<p>Get maximum value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Number (int|float) - Maximum value.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def get(self) -&gt; Any:\n    \"\"\"Get maximum value.\n\n    Returns:\n        Number (int|float) - Maximum value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    if number &gt; self.value:\n        self.value = number\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min","title":"<code>Min</code>","text":"<p>Aggregation class for calculating the minimum value.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>class Min:\n    \"\"\"Aggregation class for calculating the minimum value.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value: Any = 0\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        if self.value == 0 or number &lt; self.value:\n            self.value = number\n\n    def get(self) -&gt; Any:\n        \"\"\"Get minimum value.\n\n        Returns:\n            Number (int|float) - Minimum value.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min.get","title":"<code>get()</code>","text":"<p>Get minimum value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Number (int|float) - Minimum value.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def get(self) -&gt; Any:\n    \"\"\"Get minimum value.\n\n    Returns:\n        Number (int|float) - Minimum value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    if self.value == 0 or number &lt; self.value:\n        self.value = number\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum","title":"<code>Sum</code>","text":"<p>Aggregation class for calculating sum of values.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>class Sum:\n    \"\"\"Aggregation class for calculating sum of values.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value = Decimal()\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        self.value += Decimal(str(number))\n\n    def get(self) -&gt; Decimal:\n        \"\"\"Get sum of values.\n\n        Returns:\n            Number (int|float) - Sum of values.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum.get","title":"<code>get()</code>","text":"<p>Get sum of values.</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>Number (int|float) - Sum of values.</p> Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def get(self) -&gt; Decimal:\n    \"\"\"Get sum of values.\n\n    Returns:\n        Number (int|float) - Sum of values.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src\\scruby\\aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    self.value += Decimal(str(number))\n</code></pre>"},{"location":"pages/constants/","title":"Constants","text":"<p>Constant variables.</p> <p>The module contains the following variables:</p> <ul> <li><code>DB_ROOT</code> - Path to root directory of database. <code>By default = \"ScrubyDB\"</code> (in root of project).</li> <li><code>HASH_REDUCE_LEFT</code> - The length of the hash reduction on the left side.<ul> <li><code>0</code> - 4294967296 branches in collection (by default).</li> <li><code>2</code> - 16777216 branches in collection\u044e</li> <li><code>4</code> - 65536 branches in collection\u044e</li> <li><code>6</code> - 256 branches in collection (main purpose is tests).</li> </ul> </li> </ul>"},{"location":"pages/db/","title":"DataBase","text":"<p>Creation and management of the database.</p>"},{"location":"pages/db/#scruby.db.Scruby","title":"<code>Scruby</code>","text":"<p>Creation and management of database.</p> <p>Parameters:</p> Name Type Description Default <code>class_model</code> <code>T</code> <p>Class of Model (Pydantic).</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>class Scruby[T]:\n    \"\"\"Creation and management of database.\n\n    Args:\n        class_model: Class of Model (Pydantic).\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        class_model: T,\n    ) -&gt; None:\n        self.__meta = _Meta\n        self.__class_model = class_model\n        self.__db_root = constants.DB_ROOT\n        self.__hash_reduce_left = constants.HASH_REDUCE_LEFT\n        # The maximum number of branches.\n        match self.__hash_reduce_left:\n            case 0:\n                self.__max_branch_number = 4294967296\n            case 2:\n                self.__max_branch_number = 16777216\n            case 4:\n                self.__max_branch_number = 65536\n            case 6:\n                self.__max_branch_number = 256\n            case _ as unreachable:\n                msg: str = f\"{unreachable} - Unacceptable value for HASH_REDUCE_LEFT.\"\n                logger.critical(msg)\n                assert_never(Never(unreachable))\n        # Caching a pati for metadata in the form of a tuple.\n        # The zero branch is reserved for metadata.\n        branch_number: int = 0\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[constants.HASH_REDUCE_LEFT :]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        self.__meta_path_tuple = (\n            constants.DB_ROOT,\n            class_model.__name__,\n            separated_hash,\n            \"meta.json\",\n        )\n        # Create metadata for collection, if required.\n        branch_path = SyncPath(\n            *(\n                self.__db_root,\n                self.__class_model.__name__,\n                separated_hash,\n            ),\n        )\n        if not branch_path.exists():\n            branch_path.mkdir(parents=True)\n            meta = _Meta(\n                counter_documents=0,\n            )\n            meta_json = meta.model_dump_json()\n            meta_path = SyncPath(*(branch_path, \"meta.json\"))\n            meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _get_meta(self) -&gt; _Meta:\n        \"\"\"Asynchronous method for getting metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            Metadata object.\n        \"\"\"\n        meta_path = Path(*self.__meta_path_tuple)\n        meta_json = await meta_path.read_text()\n        meta: _Meta = self.__meta.model_validate_json(meta_json)\n        return meta\n\n    async def _set_meta(self, meta: _Meta) -&gt; None:\n        \"\"\"Asynchronous method for updating metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            None.\n        \"\"\"\n        meta_json = meta.model_dump_json()\n        meta_path = Path(*self.__meta_path_tuple)\n        await meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _counter_documents(self, step: Literal[1, -1]) -&gt; None:\n        \"\"\"Asynchronous method for management of documents in metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            None.\n        \"\"\"\n        meta_path = Path(*self.__meta_path_tuple)\n        meta_json = await meta_path.read_text(\"utf-8\")\n        meta: _Meta = self.__meta.model_validate_json(meta_json)\n        meta.counter_documents += step\n        meta_json = meta.model_dump_json()\n        await meta_path.write_text(meta_json, \"utf-8\")\n\n    def _sync_counter_documents(self, number: int) -&gt; None:\n        \"\"\"Management of documents in metadata of collection.\n\n        This method is for internal use.\n        \"\"\"\n        meta_path = SyncPath(*self.__meta_path_tuple)\n        meta_json = meta_path.read_text(\"utf-8\")\n        meta: _Meta = self.__meta.model_validate_json(meta_json)\n        meta.counter_documents += number\n        meta_json = meta.model_dump_json()\n        meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _get_leaf_path(self, key: str) -&gt; Path:\n        \"\"\"Asynchronous method for getting path to collection cell by key.\n\n        This method is for internal use.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            Path to cell of collection.\n        \"\"\"\n        if not isinstance(key, str):\n            logger.error(\"The key is not a type of `str`.\")\n            raise KeyError(\"The key is not a type of `str`.\")\n        if len(key) == 0:\n            logger.error(\"The key should not be empty.\")\n            raise KeyError(\"The key should not be empty.\")\n        # Key to crc32 sum.\n        key_as_hash: str = f\"{zlib.crc32(key.encode('utf-8')):08x}\"[self.__hash_reduce_left :]\n        # Convert crc32 sum in the segment of path.\n        separated_hash: str = \"/\".join(list(key_as_hash))\n        # The path of the branch to the database.\n        branch_path: Path = Path(\n            *(\n                self.__db_root,\n                self.__class_model.__name__,\n                separated_hash,\n            ),\n        )\n        # If the branch does not exist, need to create it.\n        if not await branch_path.exists():\n            await branch_path.mkdir(parents=True)\n        # The path to the database cell.\n        leaf_path: Path = Path(*(branch_path, \"leaf.json\"))\n        return leaf_path\n\n    async def add_key(\n        self,\n        key: str,\n        value: T,\n    ) -&gt; None:\n        \"\"\"Asynchronous method for adding key to collection.\n\n        Args:\n            key: Key name. Type `str`.\n            value: Value of key. Type `BaseModel`.\n\n        Returns:\n            None.\n        \"\"\"\n        # The path to cell of collection.\n        leaf_path: Path = await self._get_leaf_path(key)\n        value_json: str = value.model_dump_json()\n        # Write key-value to collection.\n        if await leaf_path.exists():\n            # Add new key.\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n            except KeyError:\n                data[key] = value_json\n                await leaf_path.write_bytes(orjson.dumps(data))\n            else:\n                err = KeyAlreadyExistsError()\n                logger.error(err.message)\n                raise err\n        else:\n            # Add new key to a blank leaf.\n            await leaf_path.write_bytes(orjson.dumps({key: value_json}))\n        await self._counter_documents(1)\n\n    async def update_key(\n        self,\n        key: str,\n        value: T,\n    ) -&gt; None:\n        \"\"\"Asynchronous method for updating key to collection.\n\n        Args:\n            key: Key name. Type `str`.\n            value: Value of key. Type `BaseModel`.\n\n        Returns:\n            None.\n        \"\"\"\n        # The path to cell of collection.\n        leaf_path: Path = await self._get_leaf_path(key)\n        value_json: str = value.model_dump_json()\n        # Update the existing key.\n        if await leaf_path.exists():\n            # Update the existing key.\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n                data[key] = value_json\n                await leaf_path.write_bytes(orjson.dumps(data))\n            except KeyError:\n                err = KeyNotExistsError()\n                logger.error(err.message)\n                raise err from None\n        else:\n            logger.error(\"The key not exists.\")\n            raise KeyError()\n\n    async def get_key(self, key: str) -&gt; T:\n        \"\"\"Asynchronous method for getting value of key from collection.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            Value of key or KeyError.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self._get_leaf_path(key)\n        # Get value of key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            obj: T = self.__class_model.model_validate_json(data[key])\n            return obj\n        msg: str = \"`get_key` - The unacceptable key value.\"\n        logger.error(msg)\n        raise KeyError()\n\n    async def has_key(self, key: str) -&gt; bool:\n        \"\"\"Asynchronous method for checking presence of key in collection.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            True, if the key is present.\n        \"\"\"\n        # Get path to cell of collection.\n        leaf_path: Path = await self._get_leaf_path(key)\n        # Checking whether there is a key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n                return True\n            except KeyError:\n                return False\n        return False\n\n    async def delete_key(self, key: str) -&gt; None:\n        \"\"\"Asynchronous method for deleting key from collection.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            None.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self._get_leaf_path(key)\n        # Deleting key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            del data[key]\n            await leaf_path.write_bytes(orjson.dumps(data))\n            await self._counter_documents(-1)\n            return\n        msg: str = \"`delete_key` - The unacceptable key value.\"\n        logger.error(msg)\n        raise KeyError()\n\n    @staticmethod\n    async def napalm() -&gt; None:\n        \"\"\"Asynchronous method for full database deletion.\n\n        The main purpose is tests.\n\n        Warning:\n            - `Be careful, this will remove all keys.`\n\n        Returns:\n            None.\n        \"\"\"\n        with contextlib.suppress(FileNotFoundError):\n            await to_thread.run_sync(rmtree, constants.DB_ROOT)\n        return\n\n    @staticmethod\n    def _task_find(\n        branch_number: int,\n        filter_fn: Callable,\n        hash_reduce_left: str,\n        db_root: str,\n        class_model: T,\n    ) -&gt; list[T] | None:\n        \"\"\"Task for find documents.\n\n        This method is for internal use.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: SyncPath = SyncPath(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        docs: list[T] = []\n        if leaf_path.exists():\n            data_json: bytes = leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            for _, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    docs.append(doc)\n        return docs or None\n\n    def find_one(\n        self,\n        filter_fn: Callable,\n        max_workers: int | None = None,\n        timeout: float | None = None,\n    ) -&gt; T | None:\n        \"\"\"Finds a single document matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            Document or None.\n        \"\"\"\n        branch_numbers: range = range(1, self.__max_branch_number)\n        search_task_fn: Callable = self._task_find\n        hash_reduce_left: int = self.__hash_reduce_left\n        db_root: str = self.__db_root\n        class_model: T = self.__class_model\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                docs = future.result(timeout)\n                if docs is not None:\n                    return docs[0]\n        return None\n\n    def find_many(\n        self,\n        filter_fn: Callable,\n        limit_docs: int = 1000,\n        max_workers: int | None = None,\n        timeout: float | None = None,\n    ) -&gt; list[T] | None:\n        \"\"\"Finds one or more documents matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            limit_docs: Limiting the number of documents. By default = 1000.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        branch_numbers: range = range(1, self.__max_branch_number)\n        search_task_fn: Callable = self._task_find\n        hash_reduce_left: int = self.__hash_reduce_left\n        db_root: str = self.__db_root\n        class_model: T = self.__class_model\n        counter: int = 0\n        result: list[T] = []\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                if counter &gt;= limit_docs:\n                    return result[:limit_docs]\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                docs = future.result(timeout)\n                if docs is not None:\n                    for doc in docs:\n                        if counter &gt;= limit_docs:\n                            return result[:limit_docs]\n                        result.append(doc)\n                        counter += 1\n        return result or None\n\n    def collection_name(self) -&gt; str:\n        \"\"\"Get collection name.\n\n        Returns:\n            Collection name.\n        \"\"\"\n        return self.__class_model.__name__\n\n    def collection_full_name(self) -&gt; str:\n        \"\"\"Get full name of collection.\n\n        Returns:\n            Full name of collection.\n        \"\"\"\n        return f\"{self.__db_root}/{self.__class_model.__name__}\"\n\n    async def estimated_document_count(self) -&gt; int:\n        \"\"\"Get an estimate of the number of documents in this collection using collection metadata.\n\n        Returns:\n            The number of documents.\n        \"\"\"\n        meta = await self._get_meta()\n        return meta.counter_documents\n\n    def count_documents(\n        self,\n        filter_fn: Callable,\n        max_workers: int | None = None,\n        timeout: float | None = None,\n    ) -&gt; int:\n        \"\"\"Count the number of documents a matching the filter in this collection.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            The number of documents.\n        \"\"\"\n        branch_numbers: range = range(1, self.__max_branch_number)\n        search_task_fn: Callable = self._task_find\n        hash_reduce_left: int = self.__hash_reduce_left\n        db_root: str = self.__db_root\n        class_model: T = self.__class_model\n        counter: int = 0\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                if future.result(timeout) is not None:\n                    counter += 1\n        return counter\n\n    @staticmethod\n    def _task_delete(\n        branch_number: int,\n        filter_fn: Callable,\n        hash_reduce_left: int,\n        db_root: str,\n        class_model: T,\n    ) -&gt; int:\n        \"\"\"Task for find and delete documents.\n\n        This method is for internal use.\n\n        Returns:\n            The number of deleted documents.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: SyncPath = SyncPath(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        counter: int = 0\n        if leaf_path.exists():\n            data_json: bytes = leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            new_state: dict[str, str] = {}\n            for key, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    counter -= 1\n                else:\n                    new_state[key] = val\n            leaf_path.write_bytes(orjson.dumps(new_state))\n        return counter\n\n    def delete_many(\n        self,\n        filter_fn: Callable,\n        max_workers: int | None = None,\n        timeout: float | None = None,\n    ) -&gt; int:\n        \"\"\"Delete one or more documents matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            The number of deleted documents.\n        \"\"\"\n        branch_numbers: range = range(1, self.__max_branch_number)\n        search_task_fn: Callable = self._task_delete\n        hash_reduce_left: int = self.__hash_reduce_left\n        db_root: str = self.__db_root\n        class_model: T = self.__class_model\n        counter: int = 0\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                counter += future.result(timeout)\n        if counter &lt; 0:\n            self._sync_counter_documents(counter)\n        return abs(counter)\n\n    @staticmethod\n    def _task_get_docs(\n        branch_number: int,\n        hash_reduce_left: int,\n        db_root: str,\n        class_model: T,\n    ) -&gt; list[Any]:\n        \"\"\"Get documents for custom task.\n\n        This method is for internal use.\n\n        Returns:\n            List of documents.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: SyncPath = SyncPath(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        docs: list[str, T] = []\n        if leaf_path.exists():\n            data_json: bytes = leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            for _, val in data.items():\n                docs.append(class_model.model_validate_json(val))\n        return docs\n\n    def run_custom_task(self, custom_task_fn: Callable, limit_docs: int = 1000) -&gt; Any:\n        \"\"\"Running custom task.\n\n        This method running a task created on the basis of a quantum loop.\n        Effectiveness running task depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            custom_task_fn: A function that execute the custom task.\n            limit_docs: Limiting the number of documents. By default = 1000.\n\n        Returns:\n            The result of a custom task.\n        \"\"\"\n        kwargs = {\n            \"get_docs_fn\": self._task_get_docs,\n            \"branch_numbers\": range(1, self.__max_branch_number),\n            \"hash_reduce_left\": self.__hash_reduce_left,\n            \"db_root\": self.__db_root,\n            \"class_model\": self.__class_model,\n            \"limit_docs\": limit_docs,\n        }\n        return custom_task_fn(**kwargs)\n\n    @staticmethod\n    def _task_update(\n        branch_number: int,\n        filter_fn: Callable,\n        hash_reduce_left: str,\n        db_root: str,\n        class_model: T,\n        new_data: dict[str, Any],\n    ) -&gt; int:\n        \"\"\"Task for find documents.\n\n        This method is for internal use.\n\n        Returns:\n            The number of updated documents.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: SyncPath = SyncPath(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        counter: int = 0\n        if leaf_path.exists():\n            data_json: bytes = leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            new_state: dict[str, str] = {}\n            for _, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    for key, value in new_data.items():\n                        doc.__dict__[key] = value\n                        new_state[key] = doc.model_dump_json()\n                    counter += 1\n            leaf_path.write_bytes(orjson.dumps(new_state))\n        return counter\n\n    def update_many(\n        self,\n        filter_fn: Callable,\n        new_data: dict[str, Any],\n        max_workers: int | None = None,\n        timeout: float | None = None,\n    ) -&gt; int:\n        \"\"\"Updates one or more documents matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            new_data: New data for the fields that need to be updated.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            The number of updated documents.\n        \"\"\"\n        branch_numbers: range = range(1, self.__max_branch_number)\n        update_task_fn: Callable = self._task_update\n        hash_reduce_left: int = self.__hash_reduce_left\n        db_root: str = self.__db_root\n        class_model: T = self.__class_model\n        counter: int = 0\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    update_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                    new_data,\n                )\n                counter += future.result(timeout)\n        return counter\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.add_key","title":"<code>add_key(key, value)</code>  <code>async</code>","text":"<p>Asynchronous method for adding key to collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name. Type <code>str</code>.</p> required <code>value</code> <code>T</code> <p>Value of key. Type <code>BaseModel</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>async def add_key(\n    self,\n    key: str,\n    value: T,\n) -&gt; None:\n    \"\"\"Asynchronous method for adding key to collection.\n\n    Args:\n        key: Key name. Type `str`.\n        value: Value of key. Type `BaseModel`.\n\n    Returns:\n        None.\n    \"\"\"\n    # The path to cell of collection.\n    leaf_path: Path = await self._get_leaf_path(key)\n    value_json: str = value.model_dump_json()\n    # Write key-value to collection.\n    if await leaf_path.exists():\n        # Add new key.\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n        except KeyError:\n            data[key] = value_json\n            await leaf_path.write_bytes(orjson.dumps(data))\n        else:\n            err = KeyAlreadyExistsError()\n            logger.error(err.message)\n            raise err\n    else:\n        # Add new key to a blank leaf.\n        await leaf_path.write_bytes(orjson.dumps({key: value_json}))\n    await self._counter_documents(1)\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.collection_full_name","title":"<code>collection_full_name()</code>","text":"<p>Get full name of collection.</p> <p>Returns:</p> Type Description <code>str</code> <p>Full name of collection.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def collection_full_name(self) -&gt; str:\n    \"\"\"Get full name of collection.\n\n    Returns:\n        Full name of collection.\n    \"\"\"\n    return f\"{self.__db_root}/{self.__class_model.__name__}\"\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.collection_name","title":"<code>collection_name()</code>","text":"<p>Get collection name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Collection name.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def collection_name(self) -&gt; str:\n    \"\"\"Get collection name.\n\n    Returns:\n        Collection name.\n    \"\"\"\n    return self.__class_model.__name__\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.count_documents","title":"<code>count_documents(filter_fn, max_workers=None, timeout=None)</code>","text":"<p>Count the number of documents a matching the filter in this collection.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of documents.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def count_documents(\n    self,\n    filter_fn: Callable,\n    max_workers: int | None = None,\n    timeout: float | None = None,\n) -&gt; int:\n    \"\"\"Count the number of documents a matching the filter in this collection.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        The number of documents.\n    \"\"\"\n    branch_numbers: range = range(1, self.__max_branch_number)\n    search_task_fn: Callable = self._task_find\n    hash_reduce_left: int = self.__hash_reduce_left\n    db_root: str = self.__db_root\n    class_model: T = self.__class_model\n    counter: int = 0\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            if future.result(timeout) is not None:\n                counter += 1\n    return counter\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.delete_key","title":"<code>delete_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for deleting key from collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>async def delete_key(self, key: str) -&gt; None:\n    \"\"\"Asynchronous method for deleting key from collection.\n\n    Args:\n        key: Key name.\n\n    Returns:\n        None.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self._get_leaf_path(key)\n    # Deleting key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        del data[key]\n        await leaf_path.write_bytes(orjson.dumps(data))\n        await self._counter_documents(-1)\n        return\n    msg: str = \"`delete_key` - The unacceptable key value.\"\n    logger.error(msg)\n    raise KeyError()\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.delete_many","title":"<code>delete_many(filter_fn, max_workers=None, timeout=None)</code>","text":"<p>Delete one or more documents matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of deleted documents.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def delete_many(\n    self,\n    filter_fn: Callable,\n    max_workers: int | None = None,\n    timeout: float | None = None,\n) -&gt; int:\n    \"\"\"Delete one or more documents matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        The number of deleted documents.\n    \"\"\"\n    branch_numbers: range = range(1, self.__max_branch_number)\n    search_task_fn: Callable = self._task_delete\n    hash_reduce_left: int = self.__hash_reduce_left\n    db_root: str = self.__db_root\n    class_model: T = self.__class_model\n    counter: int = 0\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            counter += future.result(timeout)\n    if counter &lt; 0:\n        self._sync_counter_documents(counter)\n    return abs(counter)\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.estimated_document_count","title":"<code>estimated_document_count()</code>  <code>async</code>","text":"<p>Get an estimate of the number of documents in this collection using collection metadata.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of documents.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>async def estimated_document_count(self) -&gt; int:\n    \"\"\"Get an estimate of the number of documents in this collection using collection metadata.\n\n    Returns:\n        The number of documents.\n    \"\"\"\n    meta = await self._get_meta()\n    return meta.counter_documents\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.find_many","title":"<code>find_many(filter_fn, limit_docs=1000, max_workers=None, timeout=None)</code>","text":"<p>Finds one or more documents matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>limit_docs</code> <code>int</code> <p>Limiting the number of documents. By default = 1000.</p> <code>1000</code> <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[T] | None</code> <p>List of documents or None.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def find_many(\n    self,\n    filter_fn: Callable,\n    limit_docs: int = 1000,\n    max_workers: int | None = None,\n    timeout: float | None = None,\n) -&gt; list[T] | None:\n    \"\"\"Finds one or more documents matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        limit_docs: Limiting the number of documents. By default = 1000.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        List of documents or None.\n    \"\"\"\n    branch_numbers: range = range(1, self.__max_branch_number)\n    search_task_fn: Callable = self._task_find\n    hash_reduce_left: int = self.__hash_reduce_left\n    db_root: str = self.__db_root\n    class_model: T = self.__class_model\n    counter: int = 0\n    result: list[T] = []\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            if counter &gt;= limit_docs:\n                return result[:limit_docs]\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            if docs is not None:\n                for doc in docs:\n                    if counter &gt;= limit_docs:\n                        return result[:limit_docs]\n                    result.append(doc)\n                    counter += 1\n    return result or None\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.find_one","title":"<code>find_one(filter_fn, max_workers=None, timeout=None)</code>","text":"<p>Finds a single document matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> <code>None</code> <p>Returns:</p> Type Description <code>T | None</code> <p>Document or None.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def find_one(\n    self,\n    filter_fn: Callable,\n    max_workers: int | None = None,\n    timeout: float | None = None,\n) -&gt; T | None:\n    \"\"\"Finds a single document matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        Document or None.\n    \"\"\"\n    branch_numbers: range = range(1, self.__max_branch_number)\n    search_task_fn: Callable = self._task_find\n    hash_reduce_left: int = self.__hash_reduce_left\n    db_root: str = self.__db_root\n    class_model: T = self.__class_model\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            if docs is not None:\n                return docs[0]\n    return None\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.get_key","title":"<code>get_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for getting value of key from collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>T</code> <p>Value of key or KeyError.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>async def get_key(self, key: str) -&gt; T:\n    \"\"\"Asynchronous method for getting value of key from collection.\n\n    Args:\n        key: Key name.\n\n    Returns:\n        Value of key or KeyError.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self._get_leaf_path(key)\n    # Get value of key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        obj: T = self.__class_model.model_validate_json(data[key])\n        return obj\n    msg: str = \"`get_key` - The unacceptable key value.\"\n    logger.error(msg)\n    raise KeyError()\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.has_key","title":"<code>has_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for checking presence of key in collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True, if the key is present.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>async def has_key(self, key: str) -&gt; bool:\n    \"\"\"Asynchronous method for checking presence of key in collection.\n\n    Args:\n        key: Key name.\n\n    Returns:\n        True, if the key is present.\n    \"\"\"\n    # Get path to cell of collection.\n    leaf_path: Path = await self._get_leaf_path(key)\n    # Checking whether there is a key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n            return True\n        except KeyError:\n            return False\n    return False\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.napalm","title":"<code>napalm()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Asynchronous method for full database deletion.</p> <p>The main purpose is tests.</p> Warning <ul> <li><code>Be careful, this will remove all keys.</code></li> </ul> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>@staticmethod\nasync def napalm() -&gt; None:\n    \"\"\"Asynchronous method for full database deletion.\n\n    The main purpose is tests.\n\n    Warning:\n        - `Be careful, this will remove all keys.`\n\n    Returns:\n        None.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        await to_thread.run_sync(rmtree, constants.DB_ROOT)\n    return\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.run_custom_task","title":"<code>run_custom_task(custom_task_fn, limit_docs=1000)</code>","text":"<p>Running custom task.</p> <p>This method running a task created on the basis of a quantum loop. Effectiveness running task depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>custom_task_fn</code> <code>Callable</code> <p>A function that execute the custom task.</p> required <code>limit_docs</code> <code>int</code> <p>Limiting the number of documents. By default = 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of a custom task.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def run_custom_task(self, custom_task_fn: Callable, limit_docs: int = 1000) -&gt; Any:\n    \"\"\"Running custom task.\n\n    This method running a task created on the basis of a quantum loop.\n    Effectiveness running task depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        custom_task_fn: A function that execute the custom task.\n        limit_docs: Limiting the number of documents. By default = 1000.\n\n    Returns:\n        The result of a custom task.\n    \"\"\"\n    kwargs = {\n        \"get_docs_fn\": self._task_get_docs,\n        \"branch_numbers\": range(1, self.__max_branch_number),\n        \"hash_reduce_left\": self.__hash_reduce_left,\n        \"db_root\": self.__db_root,\n        \"class_model\": self.__class_model,\n        \"limit_docs\": limit_docs,\n    }\n    return custom_task_fn(**kwargs)\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.update_key","title":"<code>update_key(key, value)</code>  <code>async</code>","text":"<p>Asynchronous method for updating key to collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name. Type <code>str</code>.</p> required <code>value</code> <code>T</code> <p>Value of key. Type <code>BaseModel</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>async def update_key(\n    self,\n    key: str,\n    value: T,\n) -&gt; None:\n    \"\"\"Asynchronous method for updating key to collection.\n\n    Args:\n        key: Key name. Type `str`.\n        value: Value of key. Type `BaseModel`.\n\n    Returns:\n        None.\n    \"\"\"\n    # The path to cell of collection.\n    leaf_path: Path = await self._get_leaf_path(key)\n    value_json: str = value.model_dump_json()\n    # Update the existing key.\n    if await leaf_path.exists():\n        # Update the existing key.\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n            data[key] = value_json\n            await leaf_path.write_bytes(orjson.dumps(data))\n        except KeyError:\n            err = KeyNotExistsError()\n            logger.error(err.message)\n            raise err from None\n    else:\n        logger.error(\"The key not exists.\")\n        raise KeyError()\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.update_many","title":"<code>update_many(filter_fn, new_data, max_workers=None, timeout=None)</code>","text":"<p>Updates one or more documents matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>new_data</code> <code>dict[str, Any]</code> <p>New data for the fields that need to be updated.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of updated documents.</p> Source code in <code>src\\scruby\\db.py</code> <pre><code>def update_many(\n    self,\n    filter_fn: Callable,\n    new_data: dict[str, Any],\n    max_workers: int | None = None,\n    timeout: float | None = None,\n) -&gt; int:\n    \"\"\"Updates one or more documents matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        new_data: New data for the fields that need to be updated.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        The number of updated documents.\n    \"\"\"\n    branch_numbers: range = range(1, self.__max_branch_number)\n    update_task_fn: Callable = self._task_update\n    hash_reduce_left: int = self.__hash_reduce_left\n    db_root: str = self.__db_root\n    class_model: T = self.__class_model\n    counter: int = 0\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                update_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n                new_data,\n            )\n            counter += future.result(timeout)\n    return counter\n</code></pre>"},{"location":"pages/errors/","title":"Errors","text":"<p>Scruby Exceptions.</p>"},{"location":"pages/errors/#scruby.errors.KeyAlreadyExistsError","title":"<code>KeyAlreadyExistsError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised if the key already exists.</p> Source code in <code>src\\scruby\\errors.py</code> <pre><code>class KeyAlreadyExistsError(ScrubyException):\n    \"\"\"Exception is raised if the key already exists.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.message = \"The key already exists.\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.KeyNotExistsError","title":"<code>KeyNotExistsError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised If the key is not exists.</p> Source code in <code>src\\scruby\\errors.py</code> <pre><code>class KeyNotExistsError(ScrubyException):\n    \"\"\"Exception is raised If the key is not exists.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.message = \"The key not exists.\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.MetadataValueError","title":"<code>MetadataValueError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised if value of variable in metadata does not matching expected.</p> Source code in <code>src\\scruby\\errors.py</code> <pre><code>class MetadataValueError(ScrubyException):\n    \"\"\"Exception is raised if value of variable in metadata does not matching expected.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.ScrubyException","title":"<code>ScrubyException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Custom Exception.</p> Source code in <code>src\\scruby\\errors.py</code> <pre><code>class ScrubyException(Exception):\n    \"\"\"Root Custom Exception.\"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:  # type: ignore[no-untyped-def]  # noqa: D107\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"pages/installation/","title":"Installation","text":"<pre><code>uv add scruby\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"<p>Example collection of how to use a database.</p>"},{"location":"pages/usage/aggregation/","title":"Aggregation classes","text":""},{"location":"pages/usage/aggregation/#average","title":"Average","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the average value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom decimal import ROUND_HALF_EVEN\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Average\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_average(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; float:\n    \"\"\"Custom task.\n\n    Calculate the average value.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    average_age = Average(\n        precision=\".00\",           # by default = .00\n        rounding=ROUND_HALF_EVEN,  # by default = ROUND_HALF_EVEN\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                average_age.set(doc.age)\n    return float(average_age.get())\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_average)\n    print(result)  # =&gt; 50.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#counter","title":"Counter","text":"main.py<pre><code>\"\"\"Aggregation class for calculating sum of values.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Counter\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_counter(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; list[User]:\n    \"\"\"Custom task.\n\n    This task implements a counter of documents.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    users: list[User] = []\n    counter = Counter(limit=limit_docs)  # `limit` by default = 1000\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                if counter.check():\n                    # [:limit_docs] - Control overflow in a multithreaded environment.\n                    return users[:limit_docs]\n                users.append(doc)\n                counter.next()\n    return users\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(\n        custom_task_fn=task_counter,\n        limit_docs=5,\n    )\n    print(len(result))  # =&gt; 5\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#max","title":"Max","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the maximum value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Max\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_max(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the max value.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    max_age = Max()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                max_age.set(doc.age)\n    return max_age.get()\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_max)\n    print(result)  # =&gt; 90.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#min","title":"Min","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the minimum value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Min\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_min(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the min value.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    min_age = Min()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                min_age.set(doc.age)\n    return min_age.get()\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_min)\n    print(result)  # =&gt; 10.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#sum","title":"Sum","text":"main.py<pre><code>\"\"\"Aggregation class for calculating sum of values.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Sum\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_sum(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the sum of values.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    sum_age = Sum()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                sum_age.set(doc.age)\n    return int(sum_age.get())\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_sum)\n    print(result)  # =&gt; 450.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/count_documents/","title":"Count documents","text":""},{"location":"pages/usage/count_documents/#get-an-estimate-of-number-of-documents-using-collection-metadata","title":"Get an estimate of number of documents using collection metadata","text":"main.py<pre><code>\"\"\"Get an estimate of the number of documents in this collection using collection metadata.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    print(await user_coll.estimated_document_count())  # =&gt; 0\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n    print(await user_coll.estimated_document_count())  # =&gt; 1\n\n    # Delete user from collection.\n    await user_coll.delete_key(\"+447986123456\")\n    print(await user_coll.estimated_document_count())  # =&gt; 0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/count_documents/#count-number-of-documents-in-collection","title":"Count number of documents in collection","text":"main.py<pre><code>\"\"\"Count the number of documents a matching the filter in this collection.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await db.set_key(f\"+44798612345{num}\", user)\n\n    result: int = user_coll.count_documents(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    print(result:)  # =&gt; 2\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/custom_task/","title":"Custom task","text":""},{"location":"pages/usage/custom_task/#custom-task","title":"Custom task","text":"main.py<pre><code>\"\"\"Running custom task.\n\nThis method running a task created on the basis of a quantum loop.\nEffectiveness running task depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nimport concurrent.futures\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef custom_task(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n) -&gt; Any:\n    \"\"\"Custom task.\n\n    Calculate the number of users named John.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    counter: int = 0\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                if doc.first_name == \"John\":\n                    counter += 1\n    return counter\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(custom_task)\n    print(result)  # =&gt; 9\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_documents/","title":"Delete documents","text":""},{"location":"pages/usage/delete_documents/#find-a-single-document-and-delete","title":"Find a single document and delete","text":"main.py<pre><code>\"\"\"Find a single document, matching the filter and delete it.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Find user by email.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.email == \"John_Smith@gmail.com\",\n    )\n    # Delete user from collection.\n    await user_coll.delete_key(user_details.phone)\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_documents/#find-one-or-more-documents-and-deletes","title":"Find one or more documents and deletes","text":"main.py<pre><code>\"\"\"Delete one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(f\"+44798612345{num}\", user)\n\n    amount_of_deleted: int = user_coll.delete_many(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    print(amount_of_deleted)  # =&gt; 2\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/find_a_single_document/","title":"Find a single document","text":""},{"location":"pages/usage/find_a_single_document/#find-a-single-document-matching-the-filter","title":"Find a single document matching the filter","text":"main.py<pre><code>\"\"\"Find a single document matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\nfrom pprint import pprint as pp\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Find user by email.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.email == \"John_Smith@gmail.com\",\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Find user by birthday.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.birthday == datetime.datetime(1970, 1, 1),\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/find_documents/","title":"Find documents","text":""},{"location":"pages/usage/find_documents/#find-one-or-more-documents-matching-the-filter","title":"Find one or more documents matching the filter","text":"main.py<pre><code>\"\"\"Find one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\nfrom pprint import pprint as pp\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    # Find users by email.\n    users: list[User] | None = user_coll.find_many(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    if users is not None:\n        pp(users)\n    else:\n        print(\"No users!\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/get_collection_name/","title":"Get collection name","text":""},{"location":"pages/usage/get_collection_name/#get-collection-name","title":"Get collection name","text":"main.py<pre><code>\"\"\"Get collection name.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    print(user_coll.collection_name())  # \"User\"\n    print(user_coll.collection_full_name())  # \"ScrubyDB/User\"\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/update_documents/","title":"Update documents","text":""},{"location":"pages/usage/update_documents/#update-documents","title":"Update documents","text":"main.py<pre><code>\"\"\"Update one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # 256 branches in collection\n                                # (main purpose is tests).\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    number_updated_users = user_coll.update_many(\n        filter_fn=lambda _: True,  # Update all documents.\n        new_data={\"first_name\": \"Georg\"},\n    )\n    print(number_updated_users)  # =&gt; 9\n\n    users: list[User] | None = user_coll.find_many(\n        filter_fn=lambda _: True,  # Find all documents\n    )\n    for user in users:\n        print(user.first_name)  # =&gt; Georg\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/working_with_keys/","title":"Working with keys","text":""},{"location":"pages/usage/working_with_keys/#working-with-keys","title":"Working with keys","text":"main.py<pre><code>\"\"\"Working with keys.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add data of user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Update data of  user to collection.\n    await user_coll.update_key(user.phone, user)\n\n    # Get user from collection.\n    await user_coll.get_key(\"+447986123456\")  # =&gt; user\n    await user_coll.get_key(\"key missing\")  # =&gt; KeyError\n\n    await user_coll.has_key(\"+447986123456\")  # =&gt; True\n    await user_coll.has_key(\"key missing\")  # =&gt; False\n\n    await user_coll.delete_key(\"+447986123456\")\n    await user_coll.delete_key(\"+447986123456\")  # =&gt; KeyError\n    await user_coll.delete_key(\"key missing\")  # =&gt; KeyError\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"}]}