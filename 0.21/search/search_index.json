{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Scruby","text":"<p> Asynchronous library for building and managing a hybrid database,by scheme of key-value. <p> </p> </p> <p></p> <p>   The library uses fractal-tree addressing and      the search for documents based on the effect of a quantum loop.       The database consists of collections.      The maximum size of the one collection is 16\\*\\*8=4294967296 branches,      each branch can store one or more keys.       The value of any key in collection can be obtained in 8 steps,      thereby achieving high performance.       The effectiveness of the search for documents based on a quantum loop,      requires a large number of processor threads. </p> <p></p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/aggregation/","title":"Aggregation classes","text":"<p>Aggregation classes.</p>"},{"location":"pages/aggregation/#scruby.aggregation.Average","title":"<code>Average</code>","text":"<p>Aggregation class for calculating the average value.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>str</code> <p>The accuracy of rounding. <code>By default = .00</code></p> <code>'.00'</code> <code>rounding</code> <code>str</code> <p>Rounding mode. <code>By default = ROUND_HALF_EVEN</code></p> <code>ROUND_HALF_EVEN</code> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Average:\n    \"\"\"Aggregation class for calculating the average value.\n\n    Args:\n        precision: The accuracy of rounding. `By default = .00`\n        rounding: Rounding mode. `By default = ROUND_HALF_EVEN`\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        precision: str = \".00\",\n        rounding: str = ROUND_HALF_EVEN,\n    ) -&gt; None:\n        self.value = Decimal()\n        self.counter = 0\n        self.precision = precision\n        self.rounding = rounding\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value (int | float).\n        \"\"\"\n        self.value += Decimal(str(number))\n        self.counter += 1\n\n    def get(self) -&gt; Decimal:\n        \"\"\"Get arithmetic average value.\n\n        Returns:\n            Number (Decimal) - Average value.\n        \"\"\"\n        return (self.value / Decimal(str(self.counter))).quantize(\n            exp=Decimal(self.precision),\n            rounding=self.rounding,\n        )\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Average.get","title":"<code>get()</code>","text":"<p>Get arithmetic average value.</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>Number (Decimal) - Average value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Decimal:\n    \"\"\"Get arithmetic average value.\n\n    Returns:\n        Number (Decimal) - Average value.\n    \"\"\"\n    return (self.value / Decimal(str(self.counter))).quantize(\n        exp=Decimal(self.precision),\n        rounding=self.rounding,\n    )\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Average.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value (int | float).</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value (int | float).\n    \"\"\"\n    self.value += Decimal(str(number))\n    self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter","title":"<code>Counter</code>","text":"<p>Aggregation class for calculating the number of documents.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum counter value.</p> <code>1000</code> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Counter:\n    \"\"\"Aggregation class for calculating the number of documents.\n\n    Args:\n        limit: The maximum counter value.\n    \"\"\"\n\n    def __init__(self, limit: int = 1000) -&gt; None:  # noqa: D107\n        self.limit = limit\n        self.counter = 0\n\n    def check(self) -&gt; bool:\n        \"\"\"Check the condition of the counter.\n\n        Returns:\n            Boolean value. If `True`, the maximum value is achieved.\n        \"\"\"\n        return self.counter &gt;= self.limit\n\n    def next(self) -&gt; None:\n        \"\"\"Increment the counter on one.\"\"\"\n        self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter.check","title":"<code>check()</code>","text":"<p>Check the condition of the counter.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean value. If <code>True</code>, the maximum value is achieved.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def check(self) -&gt; bool:\n    \"\"\"Check the condition of the counter.\n\n    Returns:\n        Boolean value. If `True`, the maximum value is achieved.\n    \"\"\"\n    return self.counter &gt;= self.limit\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter.next","title":"<code>next()</code>","text":"<p>Increment the counter on one.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def next(self) -&gt; None:\n    \"\"\"Increment the counter on one.\"\"\"\n    self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max","title":"<code>Max</code>","text":"<p>Aggregation class for calculating the maximum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Max:\n    \"\"\"Aggregation class for calculating the maximum value.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value: Any = 0\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        if number &gt; self.value:\n            self.value = number\n\n    def get(self) -&gt; Any:\n        \"\"\"Get maximum value.\n\n        Returns:\n            Number (int|float) - Maximum value.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max.get","title":"<code>get()</code>","text":"<p>Get maximum value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Number (int|float) - Maximum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Any:\n    \"\"\"Get maximum value.\n\n    Returns:\n        Number (int|float) - Maximum value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    if number &gt; self.value:\n        self.value = number\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min","title":"<code>Min</code>","text":"<p>Aggregation class for calculating the minimum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Min:\n    \"\"\"Aggregation class for calculating the minimum value.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value: Any = 0\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        if self.value == 0 or number &lt; self.value:\n            self.value = number\n\n    def get(self) -&gt; Any:\n        \"\"\"Get minimum value.\n\n        Returns:\n            Number (int|float) - Minimum value.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min.get","title":"<code>get()</code>","text":"<p>Get minimum value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Number (int|float) - Minimum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Any:\n    \"\"\"Get minimum value.\n\n    Returns:\n        Number (int|float) - Minimum value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    if self.value == 0 or number &lt; self.value:\n        self.value = number\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum","title":"<code>Sum</code>","text":"<p>Aggregation class for calculating sum of values.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Sum:\n    \"\"\"Aggregation class for calculating sum of values.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value = Decimal()\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        self.value += Decimal(str(number))\n\n    def get(self) -&gt; Decimal:\n        \"\"\"Get sum of values.\n\n        Returns:\n            Number (int|float) - Sum of values.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum.get","title":"<code>get()</code>","text":"<p>Get sum of values.</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>Number (int|float) - Sum of values.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Decimal:\n    \"\"\"Get sum of values.\n\n    Returns:\n        Number (int|float) - Sum of values.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    self.value += Decimal(str(number))\n</code></pre>"},{"location":"pages/constants/","title":"Constants","text":"<p>Constant variables.</p> <p>The module contains the following variables:</p> <ul> <li><code>DB_ROOT</code> - Path to root directory of database. <code>By default = \"ScrubyDB\" (in root of project)</code>.</li> <li><code>HASH_REDUCE_LEFT</code> - The length of the hash reduction on the left side.<ul> <li><code>0</code> - 4294967296 branches in collection.</li> <li><code>2</code> - 16777216 branches in collection.</li> <li><code>4</code> - 65536 branches in collection.</li> <li><code>6</code> - 256 branches in collection (by default).</li> </ul> </li> </ul> <p> Hint:  Number of branches is number of requests to the hard disk during quantum operations.  Quantum operations: find_one, find_many, count_documents, delete_many, run_custom_task. </p>"},{"location":"pages/db/","title":"DataBase","text":"<p>Creation and management of the database.</p>"},{"location":"pages/db/#scruby.db.Scruby","title":"<code>Scruby</code>","text":"<p>               Bases: <code>Keys</code>, <code>Find</code>, <code>CustomTask</code>, <code>Collection</code>, <code>Count</code>, <code>Delete</code>, <code>Update</code></p> <p>Creation and management of database.</p> <p>Parameters:</p> Name Type Description Default <code>class_model</code> <code>T</code> <p>Class of Model (Pydantic).</p> required Source code in <code>src/scruby/db.py</code> <pre><code>class Scruby[T](\n    mixins.Keys,\n    mixins.Find,\n    mixins.CustomTask,\n    mixins.Collection,\n    mixins.Count,\n    mixins.Delete,\n    mixins.Update,\n):\n    \"\"\"Creation and management of database.\n\n    Args:\n        class_model: Class of Model (Pydantic).\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        class_model: T,\n    ) -&gt; None:\n        super().__init__()\n        self._meta = _Meta\n        self._class_model = class_model\n        self._db_root = constants.DB_ROOT\n        self._hash_reduce_left = constants.HASH_REDUCE_LEFT\n        # The maximum number of branches.\n        match self._hash_reduce_left:\n            case 0:\n                self._max_branch_number = 4294967296\n            case 2:\n                self._max_branch_number = 16777216\n            case 4:\n                self._max_branch_number = 65536\n            case 6:\n                self._max_branch_number = 256\n            case _ as unreachable:\n                msg: str = f\"{unreachable} - Unacceptable value for HASH_REDUCE_LEFT.\"\n                logger.critical(msg)\n                assert_never(Never(unreachable))\n        # Caching a pati for metadata in the form of a tuple.\n        # The zero branch is reserved for metadata.\n        branch_number: int = 0\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[constants.HASH_REDUCE_LEFT :]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        self._meta_path_tuple = (\n            constants.DB_ROOT,\n            class_model.__name__,\n            separated_hash,\n            \"meta.json\",\n        )\n        # Create metadata for collection, if required.\n        branch_path = SyncPath(\n            *(\n                self._db_root,\n                self._class_model.__name__,\n                separated_hash,\n            ),\n        )\n        if not branch_path.exists():\n            branch_path.mkdir(parents=True)\n            meta = _Meta(\n                db_root=self._db_root,\n                hash_reduce_left=self._hash_reduce_left,\n                max_branch_number=self._max_branch_number,\n                counter_documents=0,\n            )\n            meta_json = meta.model_dump_json()\n            meta_path = SyncPath(*(branch_path, \"meta.json\"))\n            meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _get_meta(self) -&gt; _Meta:\n        \"\"\"Asynchronous method for getting metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            Metadata object.\n        \"\"\"\n        meta_path = Path(*self._meta_path_tuple)\n        meta_json = await meta_path.read_text()\n        meta: _Meta = self._meta.model_validate_json(meta_json)\n        return meta\n\n    async def _set_meta(self, meta: _Meta) -&gt; None:\n        \"\"\"Asynchronous method for updating metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            None.\n        \"\"\"\n        meta_json = meta.model_dump_json()\n        meta_path = Path(*self._meta_path_tuple)\n        await meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _counter_documents(self, step: Literal[1, -1]) -&gt; None:\n        \"\"\"Asynchronous method for management of documents in metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            None.\n        \"\"\"\n        meta_path = Path(*self._meta_path_tuple)\n        meta_json = await meta_path.read_text(\"utf-8\")\n        meta: _Meta = self._meta.model_validate_json(meta_json)\n        meta.counter_documents += step\n        meta_json = meta.model_dump_json()\n        await meta_path.write_text(meta_json, \"utf-8\")\n\n    def _sync_counter_documents(self, number: int) -&gt; None:\n        \"\"\"Management of documents in metadata of collection.\n\n        This method is for internal use.\n        \"\"\"\n        meta_path = SyncPath(*self._meta_path_tuple)\n        meta_json = meta_path.read_text(\"utf-8\")\n        meta: _Meta = self._meta.model_validate_json(meta_json)\n        meta.counter_documents += number\n        meta_json = meta.model_dump_json()\n        meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _get_leaf_path(self, key: str) -&gt; Path:\n        \"\"\"Asynchronous method for getting path to collection cell by key.\n\n        This method is for internal use.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            Path to cell of collection.\n        \"\"\"\n        if not isinstance(key, str):\n            logger.error(\"The key is not a type of `str`.\")\n            raise KeyError(\"The key is not a type of `str`.\")\n        if len(key) == 0:\n            logger.error(\"The key should not be empty.\")\n            raise KeyError(\"The key should not be empty.\")\n        # Key to crc32 sum.\n        key_as_hash: str = f\"{zlib.crc32(key.encode('utf-8')):08x}\"[self._hash_reduce_left :]\n        # Convert crc32 sum in the segment of path.\n        separated_hash: str = \"/\".join(list(key_as_hash))\n        # The path of the branch to the database.\n        branch_path: Path = Path(\n            *(\n                self._db_root,\n                self._class_model.__name__,\n                separated_hash,\n            ),\n        )\n        # If the branch does not exist, need to create it.\n        if not await branch_path.exists():\n            await branch_path.mkdir(parents=True)\n        # The path to the database cell.\n        leaf_path: Path = Path(*(branch_path, \"leaf.json\"))\n        return leaf_path\n\n    @staticmethod\n    def napalm() -&gt; None:\n        \"\"\"Method for full database deletion.\n\n        The main purpose is tests.\n\n        Warning:\n            - `Be careful, this will remove all keys.`\n\n        Returns:\n            None.\n        \"\"\"\n        with contextlib.suppress(FileNotFoundError):\n            rmtree(constants.DB_ROOT)\n        return\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.napalm","title":"<code>napalm()</code>  <code>staticmethod</code>","text":"<p>Method for full database deletion.</p> <p>The main purpose is tests.</p> Warning <ul> <li><code>Be careful, this will remove all keys.</code></li> </ul> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/scruby/db.py</code> <pre><code>@staticmethod\ndef napalm() -&gt; None:\n    \"\"\"Method for full database deletion.\n\n    The main purpose is tests.\n\n    Warning:\n        - `Be careful, this will remove all keys.`\n\n    Returns:\n        None.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        rmtree(constants.DB_ROOT)\n    return\n</code></pre>"},{"location":"pages/errors/","title":"Errors","text":"<p>Scruby Exceptions.</p>"},{"location":"pages/errors/#scruby.errors.KeyAlreadyExistsError","title":"<code>KeyAlreadyExistsError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised if the key already exists.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class KeyAlreadyExistsError(ScrubyException):\n    \"\"\"Exception is raised if the key already exists.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.message = \"The key already exists.\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.KeyNotExistsError","title":"<code>KeyNotExistsError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised If the key is not exists.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class KeyNotExistsError(ScrubyException):\n    \"\"\"Exception is raised If the key is not exists.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.message = \"The key not exists.\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.MetadataValueError","title":"<code>MetadataValueError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised if value of variable in metadata does not matching expected.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class MetadataValueError(ScrubyException):\n    \"\"\"Exception is raised if value of variable in metadata does not matching expected.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.ScrubyException","title":"<code>ScrubyException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Custom Exception.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class ScrubyException(Exception):\n    \"\"\"Root Custom Exception.\"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:  # type: ignore[no-untyped-def]  # noqa: D107\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"pages/installation/","title":"Installation","text":"<pre><code>uv add scruby\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"<p>Example collection of how to use a database.</p>"},{"location":"pages/usage/aggregation/","title":"Aggregation classes","text":""},{"location":"pages/usage/aggregation/#average","title":"Average","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the average value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom decimal import ROUND_HALF_EVEN\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Average\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_average(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; float:\n    \"\"\"Custom task.\n\n    Calculate the average value.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    average_age = Average(\n        precision=\".00\",           # by default = .00\n        rounding=ROUND_HALF_EVEN,  # by default = ROUND_HALF_EVEN\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                average_age.set(doc.age)\n    return float(average_age.get())\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_average)\n    print(result)  # =&gt; 50.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#counter","title":"Counter","text":"main.py<pre><code>\"\"\"Aggregation class for calculating sum of values.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Counter\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_counter(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; list[User]:\n    \"\"\"Custom task.\n\n    This task implements a counter of documents.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    users: list[User] = []\n    counter = Counter(limit=limit_docs)  # `limit` by default = 1000\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                if counter.check():\n                    # [:limit_docs] - Control overflow in a multithreaded environment.\n                    return users[:limit_docs]\n                users.append(doc)\n                counter.next()\n    return users\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(\n        custom_task_fn=task_counter,\n        limit_docs=5,\n    )\n    print(len(result))  # =&gt; 5\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#max","title":"Max","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the maximum value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Max\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_max(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the max value.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    max_age = Max()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                max_age.set(doc.age)\n    return max_age.get()\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_max)\n    print(result)  # =&gt; 90.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#min","title":"Min","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the minimum value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Min\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_min(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the min value.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    min_age = Min()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                min_age.set(doc.age)\n    return min_age.get()\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_min)\n    print(result)  # =&gt; 10.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#sum","title":"Sum","text":"main.py<pre><code>\"\"\"Aggregation class for calculating sum of values.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Sum\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef task_calculate_sum(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the sum of values.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    sum_age = Sum()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                sum_age.set(doc.age)\n    return int(sum_age.get())\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(task_calculate_sum)\n    print(result)  # =&gt; 450.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/count_documents/","title":"Count documents","text":""},{"location":"pages/usage/count_documents/#get-an-estimate-of-number-of-documents-using-collection-metadata","title":"Get an estimate of number of documents using collection metadata","text":"main.py<pre><code>\"\"\"Get an estimate of the number of documents in this collection using collection metadata.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    print(await user_coll.estimated_document_count())  # =&gt; 0\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n    print(await user_coll.estimated_document_count())  # =&gt; 1\n\n    # Delete user from collection.\n    await user_coll.delete_key(\"+447986123456\")\n    print(await user_coll.estimated_document_count())  # =&gt; 0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/count_documents/#count-number-of-documents-in-collection","title":"Count number of documents in collection","text":"main.py<pre><code>\"\"\"Count the number of documents a matching the filter in this collection.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await db.set_key(f\"+44798612345{num}\", user)\n\n    result: int = user_coll.count_documents(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    print(result:)  # =&gt; 2\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/custom_task/","title":"Custom task","text":""},{"location":"pages/usage/custom_task/#custom-task","title":"Custom task","text":"main.py<pre><code>\"\"\"Running custom task.\n\nThis method running a task created on the basis of a quantum loop.\nEffectiveness running task depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nimport concurrent.futures\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\ndef custom_task(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n) -&gt; Any:\n    \"\"\"Custom task.\n\n    Calculate the number of users named John.\n    \"\"\"\n    max_workers: int | None = None\n    timeout: float | None = None\n    counter: int = 0\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = future.result(timeout)\n            for doc in docs:\n                if doc.first_name == \"John\":\n                    counter += 1\n    return counter\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = user_coll.run_custom_task(custom_task)\n    print(result)  # =&gt; 9\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_collection/","title":"Delete collection","text":""},{"location":"pages/usage/delete_collection/#delete-collection","title":"Delete Collection","text":"main.py<pre><code>\"\"\"Delete collection.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    collection_list = await Scruby.collection_list()\n    print(ucollection_list)  # [\"User\"]\n\n    await Scruby.delete_collection(\"User\")\n\n    collection_list = await Scruby.collection_list()\n    print(ucollection_list)  # []\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_documents/","title":"Delete documents","text":""},{"location":"pages/usage/delete_documents/#find-a-single-document-and-delete","title":"Find a single document and delete","text":"main.py<pre><code>\"\"\"Find a single document, matching the filter and delete it.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Find user by email.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.email == \"John_Smith@gmail.com\",\n    )\n    # Delete user from collection.\n    await user_coll.delete_key(user_details.phone)\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_documents/#find-one-or-more-documents-and-deletes","title":"Find one or more documents and deletes","text":"main.py<pre><code>\"\"\"Delete one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(f\"+44798612345{num}\", user)\n\n    amount_of_deleted: int = user_coll.delete_many(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    print(amount_of_deleted)  # =&gt; 2\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/find_a_single_document/","title":"Find a single document","text":""},{"location":"pages/usage/find_a_single_document/#find-a-single-document-matching-the-filter","title":"Find a single document matching the filter","text":"main.py<pre><code>\"\"\"Find a single document matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\nfrom pprint import pprint as pp\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Find user by email.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.email == \"John_Smith@gmail.com\",\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Find user by birthday.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.birthday == datetime.datetime(1970, 1, 1),\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/find_documents/","title":"Find documents","text":""},{"location":"pages/usage/find_documents/#find-one-or-more-documents-matching-the-filter","title":"Find one or more documents matching the filter","text":"main.py<pre><code>\"\"\"Find one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\nfrom pprint import pprint as pp\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    # Find users by email.\n    users: list[User] | None = user_coll.find_many(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    if users is not None:\n        pp(users)\n    else:\n        print(\"No users!\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/get_collection_list/","title":"Get collection list","text":""},{"location":"pages/usage/get_collection_list/#get-collection-list","title":"Get collection list","text":"main.py<pre><code>\"\"\"Get collection list.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    collection_list = await Scruby.collection_list()\n    print(ucollection_list)  # [\"User\"]\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/get_collection_name/","title":"Get collection name","text":""},{"location":"pages/usage/get_collection_name/#get-collection-name","title":"Get collection name","text":"main.py<pre><code>\"\"\"Get collection name.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    print(user_coll.collection_name())  # \"User\"\n    print(user_coll.collection_full_name())  # \"ScrubyDB/User\"\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/update_documents/","title":"Update documents","text":""},{"location":"pages/usage/update_documents/#update-documents","title":"Update documents","text":"main.py<pre><code>\"\"\"Update one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    number_updated_users = user_coll.update_many(\n        filter_fn=lambda _: True,  # Update all documents.\n        new_data={\"first_name\": \"Georg\"},\n    )\n    print(number_updated_users)  # =&gt; 9\n\n    users: list[User] | None = user_coll.find_many(\n        filter_fn=lambda _: True,  # Find all documents\n    )\n    for user in users:\n        print(user.first_name)  # =&gt; Georg\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/working_with_keys/","title":"Working with keys","text":""},{"location":"pages/usage/working_with_keys/#working-with-keys","title":"Working with keys","text":"main.py<pre><code>\"\"\"Working with keys.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add data of user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Update data of  user to collection.\n    await user_coll.update_key(user.phone, user)\n\n    # Get user from collection.\n    await user_coll.get_key(\"+447986123456\")  # =&gt; user\n    await user_coll.get_key(\"key missing\")  # =&gt; KeyError\n\n    await user_coll.has_key(\"+447986123456\")  # =&gt; True\n    await user_coll.has_key(\"key missing\")  # =&gt; False\n\n    await user_coll.delete_key(\"+447986123456\")\n    await user_coll.delete_key(\"+447986123456\")  # =&gt; KeyError\n    await user_coll.delete_key(\"key missing\")  # =&gt; KeyError\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"}]}