{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Scruby","text":"<p> Asynchronous library for building and managing a hybrid database,by scheme of key-value. <p> </p> </p> <p></p> <p>   The library uses fractal-tree addressing and      the search for documents based on the effect of a quantum loop.       The database consists of collections.      The maximum size of the one collection is 16\\*\\*8=4294967296 branches,      each branch can store one or more keys.       The value of any key in collection can be obtained in 8 steps,      thereby achieving high performance.       The effectiveness of the search for documents based on a quantum loop,      requires a large number of processor threads. </p> <p></p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/aggregation/","title":"Aggregation classes","text":"<p>Aggregation classes.</p>"},{"location":"pages/aggregation/#scruby.aggregation.Average","title":"<code>Average</code>","text":"<p>Aggregation class for calculating the average value.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>str</code> <p>The accuracy of rounding. <code>By default = .00</code></p> <code>'.00'</code> <code>rounding</code> <code>str</code> <p>Rounding mode. <code>By default = ROUND_HALF_EVEN</code></p> <code>ROUND_HALF_EVEN</code> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Average:\n    \"\"\"Aggregation class for calculating the average value.\n\n    Args:\n        precision: The accuracy of rounding. `By default = .00`\n        rounding: Rounding mode. `By default = ROUND_HALF_EVEN`\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        precision: str = \".00\",\n        rounding: str = ROUND_HALF_EVEN,\n    ) -&gt; None:\n        self.value = Decimal()\n        self.counter = 0\n        self.precision = precision\n        self.rounding = rounding\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value (int | float).\n        \"\"\"\n        self.value += Decimal(str(number))\n        self.counter += 1\n\n    def get(self) -&gt; Decimal:\n        \"\"\"Get arithmetic average value.\n\n        Returns:\n            Number (Decimal) - Average value.\n        \"\"\"\n        return (self.value / Decimal(str(self.counter))).quantize(\n            exp=Decimal(self.precision),\n            rounding=self.rounding,\n        )\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Average.get","title":"<code>get()</code>","text":"<p>Get arithmetic average value.</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>Number (Decimal) - Average value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Decimal:\n    \"\"\"Get arithmetic average value.\n\n    Returns:\n        Number (Decimal) - Average value.\n    \"\"\"\n    return (self.value / Decimal(str(self.counter))).quantize(\n        exp=Decimal(self.precision),\n        rounding=self.rounding,\n    )\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Average.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value (int | float).</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value (int | float).\n    \"\"\"\n    self.value += Decimal(str(number))\n    self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter","title":"<code>Counter</code>","text":"<p>Aggregation class for calculating the number of documents.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum counter value.</p> <code>1000</code> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Counter:\n    \"\"\"Aggregation class for calculating the number of documents.\n\n    Args:\n        limit: The maximum counter value.\n    \"\"\"\n\n    def __init__(self, limit: int = 1000) -&gt; None:  # noqa: D107\n        self.limit = limit\n        self.counter = 0\n\n    def check(self) -&gt; bool:\n        \"\"\"Check the condition of the counter.\n\n        Returns:\n            Boolean value. If `True`, the maximum value is achieved.\n        \"\"\"\n        return self.counter &gt;= self.limit\n\n    def next(self) -&gt; None:\n        \"\"\"Increment the counter on one.\"\"\"\n        self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter.check","title":"<code>check()</code>","text":"<p>Check the condition of the counter.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean value. If <code>True</code>, the maximum value is achieved.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def check(self) -&gt; bool:\n    \"\"\"Check the condition of the counter.\n\n    Returns:\n        Boolean value. If `True`, the maximum value is achieved.\n    \"\"\"\n    return self.counter &gt;= self.limit\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Counter.next","title":"<code>next()</code>","text":"<p>Increment the counter on one.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def next(self) -&gt; None:\n    \"\"\"Increment the counter on one.\"\"\"\n    self.counter += 1\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max","title":"<code>Max</code>","text":"<p>Aggregation class for calculating the maximum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Max:\n    \"\"\"Aggregation class for calculating the maximum value.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value: Any = 0\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        if number &gt; self.value:\n            self.value = number\n\n    def get(self) -&gt; Any:\n        \"\"\"Get maximum value.\n\n        Returns:\n            Number (int|float) - Maximum value.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max.get","title":"<code>get()</code>","text":"<p>Get maximum value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Number (int|float) - Maximum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Any:\n    \"\"\"Get maximum value.\n\n    Returns:\n        Number (int|float) - Maximum value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Max.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    if number &gt; self.value:\n        self.value = number\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min","title":"<code>Min</code>","text":"<p>Aggregation class for calculating the minimum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Min:\n    \"\"\"Aggregation class for calculating the minimum value.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value: Any = 0\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        if self.value == 0 or number &lt; self.value:\n            self.value = number\n\n    def get(self) -&gt; Any:\n        \"\"\"Get minimum value.\n\n        Returns:\n            Number (int|float) - Minimum value.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min.get","title":"<code>get()</code>","text":"<p>Get minimum value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Number (int|float) - Minimum value.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Any:\n    \"\"\"Get minimum value.\n\n    Returns:\n        Number (int|float) - Minimum value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Min.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    if self.value == 0 or number &lt; self.value:\n        self.value = number\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum","title":"<code>Sum</code>","text":"<p>Aggregation class for calculating sum of values.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>class Sum:\n    \"\"\"Aggregation class for calculating sum of values.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.value = Decimal()\n\n    def set(self, number: int | float) -&gt; None:\n        \"\"\"Add value.\n\n        Args:\n            number: Current value.\n        \"\"\"\n        self.value += Decimal(str(number))\n\n    def get(self) -&gt; Decimal:\n        \"\"\"Get sum of values.\n\n        Returns:\n            Number (int|float) - Sum of values.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum.get","title":"<code>get()</code>","text":"<p>Get sum of values.</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>Number (int|float) - Sum of values.</p> Source code in <code>src/scruby/aggregation.py</code> <pre><code>def get(self) -&gt; Decimal:\n    \"\"\"Get sum of values.\n\n    Returns:\n        Number (int|float) - Sum of values.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"pages/aggregation/#scruby.aggregation.Sum.set","title":"<code>set(number)</code>","text":"<p>Add value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int | float</code> <p>Current value.</p> required Source code in <code>src/scruby/aggregation.py</code> <pre><code>def set(self, number: int | float) -&gt; None:\n    \"\"\"Add value.\n\n    Args:\n        number: Current value.\n    \"\"\"\n    self.value += Decimal(str(number))\n</code></pre>"},{"location":"pages/constants/","title":"Constants","text":"<p>Constant variables.</p> <p>The module contains the following variables:</p> <ul> <li><code>DB_ROOT</code> - Path to root directory of database. <code>By default = \"ScrubyDB\" (in root of project)</code>.</li> <li><code>HASH_REDUCE_LEFT</code> - The length of the hash reduction on the left side.<ul> <li><code>0</code> - 4294967296 branches in collection.</li> <li><code>2</code> - 16777216 branches in collection.</li> <li><code>4</code> - 65536 branches in collection.</li> <li><code>6</code> - 256 branches in collection (by default).</li> </ul> </li> </ul> <p> Hint:  Number of branches is number of requests to the hard disk during quantum operations.  Quantum operations: find_one, find_many, count_documents, delete_many, run_custom_task. </p>"},{"location":"pages/db/","title":"Database","text":"<p>Creation and management of the database.</p>"},{"location":"pages/db/#scruby.db.Scruby","title":"<code>Scruby</code>","text":"<p>               Bases: <code>Keys</code>, <code>Find</code>, <code>CustomTask</code>, <code>Collection</code>, <code>Count</code>, <code>Delete</code>, <code>Update</code></p> <p>Creation and management of database.</p> Source code in <code>src/scruby/db.py</code> <pre><code>class Scruby[T](\n    mixins.Keys,\n    mixins.Find,\n    mixins.CustomTask,\n    mixins.Collection,\n    mixins.Count,\n    mixins.Delete,\n    mixins.Update,\n):\n    \"\"\"Creation and management of database.\"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n    ) -&gt; None:\n        super().__init__()\n        self._meta = _Meta\n        self._db_root = constants.DB_ROOT\n        self._hash_reduce_left = constants.HASH_REDUCE_LEFT\n        # The maximum number of branches.\n        match self._hash_reduce_left:\n            case 0:\n                self._max_branch_number = 4294967296\n            case 2:\n                self._max_branch_number = 16777216\n            case 4:\n                self._max_branch_number = 65536\n            case 6:\n                self._max_branch_number = 256\n            case _ as unreachable:\n                msg: str = f\"{unreachable} - Unacceptable value for HASH_REDUCE_LEFT.\"\n                logger.critical(msg)\n                assert_never(Never(unreachable))\n\n    @classmethod\n    async def create(cls, class_model: T) -&gt; Any:\n        \"\"\"Get an object to access a collection.\n\n        Args:\n            class_model: Class of Model (Pydantic).\n\n        Returns:\n            Instance of Scruby for access a collection.\n        \"\"\"\n        instance = cls()\n        instance.__dict__[\"_class_model\"] = class_model\n        # Caching a pati for metadata in the form of a tuple.\n        # The zero branch is reserved for metadata.\n        branch_number: int = 0\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[constants.HASH_REDUCE_LEFT :]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        instance.__dict__[\"_meta_path\"] = Path(\n            constants.DB_ROOT,\n            class_model.__name__,\n            separated_hash,\n            \"meta.json\",\n        )\n        # Create metadata for collection, if missing.\n        branch_path = Path(\n            constants.DB_ROOT,\n            class_model.__name__,\n            separated_hash,\n        )\n        if not await branch_path.exists():\n            await branch_path.mkdir(parents=True)\n            meta = _Meta(\n                db_root=constants.DB_ROOT,\n                collection_name=class_model.__name__,\n                hash_reduce_left=constants.HASH_REDUCE_LEFT,\n                max_branch_number=instance.__dict__[\"_max_branch_number\"],\n                counter_documents=0,\n            )\n            meta_json = meta.model_dump_json()\n            meta_path = Path(*(branch_path, \"meta.json\"))\n            await meta_path.write_text(meta_json, \"utf-8\")\n        return instance\n\n    async def get_meta(self) -&gt; _Meta:\n        \"\"\"Asynchronous method for getting metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            Metadata object.\n        \"\"\"\n        meta_json = await self._meta_path.read_text()\n        meta: _Meta = self._meta.model_validate_json(meta_json)\n        return meta\n\n    async def _set_meta(self, meta: _Meta) -&gt; None:\n        \"\"\"Asynchronous method for updating metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            None.\n        \"\"\"\n        meta_json = meta.model_dump_json()\n        await self._meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _counter_documents(self, step: Literal[1, -1]) -&gt; None:\n        \"\"\"Asynchronous method for management of documents in metadata of collection.\n\n        This method is for internal use.\n\n        Returns:\n            None.\n        \"\"\"\n        meta_path = self._meta_path\n        meta_json = await meta_path.read_text(\"utf-8\")\n        meta: _Meta = self._meta.model_validate_json(meta_json)\n        meta.counter_documents += step\n        meta_json = meta.model_dump_json()\n        await meta_path.write_text(meta_json, \"utf-8\")\n\n    async def _get_leaf_path(self, key: str) -&gt; Path:\n        \"\"\"Asynchronous method for getting path to collection cell by key.\n\n        This method is for internal use.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            Path to cell of collection.\n        \"\"\"\n        if not isinstance(key, str):\n            logger.error(\"The key is not a type of `str`.\")\n            raise KeyError(\"The key is not a type of `str`.\")\n        if len(key) == 0:\n            logger.error(\"The key should not be empty.\")\n            raise KeyError(\"The key should not be empty.\")\n        # Key to crc32 sum.\n        key_as_hash: str = f\"{zlib.crc32(key.encode('utf-8')):08x}\"[self._hash_reduce_left :]\n        # Convert crc32 sum in the segment of path.\n        separated_hash: str = \"/\".join(list(key_as_hash))\n        # The path of the branch to the database.\n        branch_path: Path = Path(\n            *(\n                self._db_root,\n                self._class_model.__name__,\n                separated_hash,\n            ),\n        )\n        # If the branch does not exist, need to create it.\n        if not await branch_path.exists():\n            await branch_path.mkdir(parents=True)\n        # The path to the database cell.\n        leaf_path: Path = Path(*(branch_path, \"leaf.json\"))\n        return leaf_path\n\n    @staticmethod\n    def napalm() -&gt; None:\n        \"\"\"Method for full database deletion.\n\n        The main purpose is tests.\n\n        Warning:\n            - `Be careful, this will remove all keys.`\n\n        Returns:\n            None.\n        \"\"\"\n        with contextlib.suppress(FileNotFoundError):\n            rmtree(constants.DB_ROOT)\n        return\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.create","title":"<code>create(class_model)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get an object to access a collection.</p> <p>Parameters:</p> Name Type Description Default <code>class_model</code> <code>T</code> <p>Class of Model (Pydantic).</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Instance of Scruby for access a collection.</p> Source code in <code>src/scruby/db.py</code> <pre><code>@classmethod\nasync def create(cls, class_model: T) -&gt; Any:\n    \"\"\"Get an object to access a collection.\n\n    Args:\n        class_model: Class of Model (Pydantic).\n\n    Returns:\n        Instance of Scruby for access a collection.\n    \"\"\"\n    instance = cls()\n    instance.__dict__[\"_class_model\"] = class_model\n    # Caching a pati for metadata in the form of a tuple.\n    # The zero branch is reserved for metadata.\n    branch_number: int = 0\n    branch_number_as_hash: str = f\"{branch_number:08x}\"[constants.HASH_REDUCE_LEFT :]\n    separated_hash: str = \"/\".join(list(branch_number_as_hash))\n    instance.__dict__[\"_meta_path\"] = Path(\n        constants.DB_ROOT,\n        class_model.__name__,\n        separated_hash,\n        \"meta.json\",\n    )\n    # Create metadata for collection, if missing.\n    branch_path = Path(\n        constants.DB_ROOT,\n        class_model.__name__,\n        separated_hash,\n    )\n    if not await branch_path.exists():\n        await branch_path.mkdir(parents=True)\n        meta = _Meta(\n            db_root=constants.DB_ROOT,\n            collection_name=class_model.__name__,\n            hash_reduce_left=constants.HASH_REDUCE_LEFT,\n            max_branch_number=instance.__dict__[\"_max_branch_number\"],\n            counter_documents=0,\n        )\n        meta_json = meta.model_dump_json()\n        meta_path = Path(*(branch_path, \"meta.json\"))\n        await meta_path.write_text(meta_json, \"utf-8\")\n    return instance\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.get_meta","title":"<code>get_meta()</code>  <code>async</code>","text":"<p>Asynchronous method for getting metadata of collection.</p> <p>This method is for internal use.</p> <p>Returns:</p> Type Description <code>_Meta</code> <p>Metadata object.</p> Source code in <code>src/scruby/db.py</code> <pre><code>async def get_meta(self) -&gt; _Meta:\n    \"\"\"Asynchronous method for getting metadata of collection.\n\n    This method is for internal use.\n\n    Returns:\n        Metadata object.\n    \"\"\"\n    meta_json = await self._meta_path.read_text()\n    meta: _Meta = self._meta.model_validate_json(meta_json)\n    return meta\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.napalm","title":"<code>napalm()</code>  <code>staticmethod</code>","text":"<p>Method for full database deletion.</p> <p>The main purpose is tests.</p> Warning <ul> <li><code>Be careful, this will remove all keys.</code></li> </ul> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/scruby/db.py</code> <pre><code>@staticmethod\ndef napalm() -&gt; None:\n    \"\"\"Method for full database deletion.\n\n    The main purpose is tests.\n\n    Warning:\n        - `Be careful, this will remove all keys.`\n\n    Returns:\n        None.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        rmtree(constants.DB_ROOT)\n    return\n</code></pre>"},{"location":"pages/errors/","title":"Errors","text":"<p>Scruby Exceptions.</p>"},{"location":"pages/errors/#scruby.errors.KeyAlreadyExistsError","title":"<code>KeyAlreadyExistsError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised if the key already exists.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class KeyAlreadyExistsError(ScrubyException):\n    \"\"\"Exception is raised if the key already exists.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.message = \"The key already exists.\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.KeyNotExistsError","title":"<code>KeyNotExistsError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised If the key is not exists.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class KeyNotExistsError(ScrubyException):\n    \"\"\"Exception is raised If the key is not exists.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.message = \"The key not exists.\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.MetadataValueError","title":"<code>MetadataValueError</code>","text":"<p>               Bases: <code>ScrubyException</code></p> <p>Exception is raised if value of variable in metadata does not matching expected.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class MetadataValueError(ScrubyException):\n    \"\"\"Exception is raised if value of variable in metadata does not matching expected.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/errors/#scruby.errors.ScrubyException","title":"<code>ScrubyException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Custom Exception.</p> Source code in <code>src/scruby/errors.py</code> <pre><code>class ScrubyException(Exception):\n    \"\"\"Root Custom Exception.\"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:  # type: ignore[no-untyped-def]  # noqa: D107\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"pages/installation/","title":"Installation","text":"<pre><code>uv add scruby\n</code></pre>"},{"location":"pages/mixins/","title":"Mixins","text":"<p>Mixins - Methods for the Scruby class.</p>"},{"location":"pages/mixins/collection/","title":"Collection","text":"<p>Methods for working with collections.</p>"},{"location":"pages/mixins/collection/#scruby.mixins.collection.Collection","title":"<code>Collection</code>","text":"<p>Methods for working with collections.</p> Source code in <code>src/scruby/mixins/collection.py</code> <pre><code>class Collection[T]:\n    \"\"\"Methods for working with collections.\"\"\"\n\n    def collection_name(self) -&gt; str:\n        \"\"\"Get collection name.\n\n        Returns:\n            Collection name.\n        \"\"\"\n        return self._class_model.__name__\n\n    def collection_full_name(self) -&gt; str:\n        \"\"\"Get full name of collection.\n\n        Returns:\n            Full name of collection.\n        \"\"\"\n        return f\"{self._db_root}/{self._class_model.__name__}\"\n\n    @staticmethod\n    async def collection_list() -&gt; list[str]:\n        \"\"\"Get collection list.\"\"\"\n        target_directory = Path(constants.DB_ROOT)\n        # Get all entries in the directory\n        all_entries = Path.iterdir(target_directory)\n        directory_names: list[str] = [entry.name async for entry in all_entries]\n        return directory_names\n\n    @staticmethod\n    async def delete_collection(name: str) -&gt; None:\n        \"\"\"Asynchronous method for deleting a collection by its name.\n\n        Args:\n            name (str): Collection name.\n\n        Returns:\n            None.\n        \"\"\"\n        target_directory = f\"{constants.DB_ROOT}/{name}\"\n        await to_thread.run_sync(rmtree, target_directory)\n        return\n</code></pre>"},{"location":"pages/mixins/collection/#scruby.mixins.collection.Collection.collection_full_name","title":"<code>collection_full_name()</code>","text":"<p>Get full name of collection.</p> <p>Returns:</p> Type Description <code>str</code> <p>Full name of collection.</p> Source code in <code>src/scruby/mixins/collection.py</code> <pre><code>def collection_full_name(self) -&gt; str:\n    \"\"\"Get full name of collection.\n\n    Returns:\n        Full name of collection.\n    \"\"\"\n    return f\"{self._db_root}/{self._class_model.__name__}\"\n</code></pre>"},{"location":"pages/mixins/collection/#scruby.mixins.collection.Collection.collection_list","title":"<code>collection_list()</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Get collection list.</p> Source code in <code>src/scruby/mixins/collection.py</code> <pre><code>@staticmethod\nasync def collection_list() -&gt; list[str]:\n    \"\"\"Get collection list.\"\"\"\n    target_directory = Path(constants.DB_ROOT)\n    # Get all entries in the directory\n    all_entries = Path.iterdir(target_directory)\n    directory_names: list[str] = [entry.name async for entry in all_entries]\n    return directory_names\n</code></pre>"},{"location":"pages/mixins/collection/#scruby.mixins.collection.Collection.collection_name","title":"<code>collection_name()</code>","text":"<p>Get collection name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Collection name.</p> Source code in <code>src/scruby/mixins/collection.py</code> <pre><code>def collection_name(self) -&gt; str:\n    \"\"\"Get collection name.\n\n    Returns:\n        Collection name.\n    \"\"\"\n    return self._class_model.__name__\n</code></pre>"},{"location":"pages/mixins/collection/#scruby.mixins.collection.Collection.delete_collection","title":"<code>delete_collection(name)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Asynchronous method for deleting a collection by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Collection name.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/scruby/mixins/collection.py</code> <pre><code>@staticmethod\nasync def delete_collection(name: str) -&gt; None:\n    \"\"\"Asynchronous method for deleting a collection by its name.\n\n    Args:\n        name (str): Collection name.\n\n    Returns:\n        None.\n    \"\"\"\n    target_directory = f\"{constants.DB_ROOT}/{name}\"\n    await to_thread.run_sync(rmtree, target_directory)\n    return\n</code></pre>"},{"location":"pages/mixins/count/","title":"Count","text":"<p>Methods for counting the number of documents.</p>"},{"location":"pages/mixins/count/#scruby.mixins.count.Count","title":"<code>Count</code>","text":"<p>Methods for counting the number of documents.</p> Source code in <code>src/scruby/mixins/count.py</code> <pre><code>class Count[T]:\n    \"\"\"Methods for counting the number of documents.\"\"\"\n\n    async def estimated_document_count(self) -&gt; int:\n        \"\"\"Get an estimate of the number of documents in this collection using collection metadata.\n\n        Returns:\n            The number of documents.\n        \"\"\"\n        meta = await self.get_meta()\n        return meta.counter_documents\n\n    async def count_documents(\n        self,\n        filter_fn: Callable,\n        max_workers: int | None = None,\n    ) -&gt; int:\n        \"\"\"Count the number of documents a matching the filter in this collection.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n\n        Returns:\n            The number of documents.\n        \"\"\"\n        branch_numbers: range = range(1, self._max_branch_number)\n        search_task_fn: Callable = self._task_find\n        hash_reduce_left: int = self._hash_reduce_left\n        db_root: str = self._db_root\n        class_model: T = self._class_model\n        counter: int = 0\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                if await future.result() is not None:\n                    counter += 1\n        return counter\n</code></pre>"},{"location":"pages/mixins/count/#scruby.mixins.count.Count.count_documents","title":"<code>count_documents(filter_fn, max_workers=None)</code>  <code>async</code>","text":"<p>Count the number of documents a matching the filter in this collection.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of documents.</p> Source code in <code>src/scruby/mixins/count.py</code> <pre><code>async def count_documents(\n    self,\n    filter_fn: Callable,\n    max_workers: int | None = None,\n) -&gt; int:\n    \"\"\"Count the number of documents a matching the filter in this collection.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n\n    Returns:\n        The number of documents.\n    \"\"\"\n    branch_numbers: range = range(1, self._max_branch_number)\n    search_task_fn: Callable = self._task_find\n    hash_reduce_left: int = self._hash_reduce_left\n    db_root: str = self._db_root\n    class_model: T = self._class_model\n    counter: int = 0\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            if await future.result() is not None:\n                counter += 1\n    return counter\n</code></pre>"},{"location":"pages/mixins/count/#scruby.mixins.count.Count.estimated_document_count","title":"<code>estimated_document_count()</code>  <code>async</code>","text":"<p>Get an estimate of the number of documents in this collection using collection metadata.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of documents.</p> Source code in <code>src/scruby/mixins/count.py</code> <pre><code>async def estimated_document_count(self) -&gt; int:\n    \"\"\"Get an estimate of the number of documents in this collection using collection metadata.\n\n    Returns:\n        The number of documents.\n    \"\"\"\n    meta = await self.get_meta()\n    return meta.counter_documents\n</code></pre>"},{"location":"pages/mixins/custom_task/","title":"Custom Task","text":"<p>Quantum methods for running custom tasks.</p>"},{"location":"pages/mixins/custom_task/#scruby.mixins.custom_task.CustomTask","title":"<code>CustomTask</code>","text":"<p>Quantum methods for running custom tasks.</p> Source code in <code>src/scruby/mixins/custom_task.py</code> <pre><code>class CustomTask[T]:\n    \"\"\"Quantum methods for running custom tasks.\"\"\"\n\n    @staticmethod\n    async def _task_get_docs(\n        branch_number: int,\n        hash_reduce_left: int,\n        db_root: str,\n        class_model: T,\n    ) -&gt; list[Any]:\n        \"\"\"Get documents for custom task.\n\n        This method is for internal use.\n\n        Returns:\n            List of documents.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: Path = Path(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        docs: list[str, T] = []\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            for _, val in data.items():\n                docs.append(class_model.model_validate_json(val))\n        return docs\n\n    async def run_custom_task(self, custom_task_fn: Callable, limit_docs: int = 1000) -&gt; Any:\n        \"\"\"Running custom task.\n\n        This method running a task created on the basis of a quantum loop.\n        Effectiveness running task depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            custom_task_fn: A function that execute the custom task.\n            limit_docs: Limiting the number of documents. By default = 1000.\n\n        Returns:\n            The result of a custom task.\n        \"\"\"\n        kwargs = {\n            \"get_docs_fn\": self._task_get_docs,\n            \"branch_numbers\": range(1, self._max_branch_number),\n            \"hash_reduce_left\": self._hash_reduce_left,\n            \"db_root\": self._db_root,\n            \"class_model\": self._class_model,\n            \"limit_docs\": limit_docs,\n        }\n        return await custom_task_fn(**kwargs)\n</code></pre>"},{"location":"pages/mixins/custom_task/#scruby.mixins.custom_task.CustomTask.run_custom_task","title":"<code>run_custom_task(custom_task_fn, limit_docs=1000)</code>  <code>async</code>","text":"<p>Running custom task.</p> <p>This method running a task created on the basis of a quantum loop. Effectiveness running task depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>custom_task_fn</code> <code>Callable</code> <p>A function that execute the custom task.</p> required <code>limit_docs</code> <code>int</code> <p>Limiting the number of documents. By default = 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of a custom task.</p> Source code in <code>src/scruby/mixins/custom_task.py</code> <pre><code>async def run_custom_task(self, custom_task_fn: Callable, limit_docs: int = 1000) -&gt; Any:\n    \"\"\"Running custom task.\n\n    This method running a task created on the basis of a quantum loop.\n    Effectiveness running task depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        custom_task_fn: A function that execute the custom task.\n        limit_docs: Limiting the number of documents. By default = 1000.\n\n    Returns:\n        The result of a custom task.\n    \"\"\"\n    kwargs = {\n        \"get_docs_fn\": self._task_get_docs,\n        \"branch_numbers\": range(1, self._max_branch_number),\n        \"hash_reduce_left\": self._hash_reduce_left,\n        \"db_root\": self._db_root,\n        \"class_model\": self._class_model,\n        \"limit_docs\": limit_docs,\n    }\n    return await custom_task_fn(**kwargs)\n</code></pre>"},{"location":"pages/mixins/delete/","title":"Delete","text":"<p>Methods for deleting documents.</p>"},{"location":"pages/mixins/delete/#scruby.mixins.delete.Delete","title":"<code>Delete</code>","text":"<p>Methods for deleting documents.</p> Source code in <code>src/scruby/mixins/delete.py</code> <pre><code>class Delete[T]:\n    \"\"\"Methods for deleting documents.\"\"\"\n\n    @staticmethod\n    async def _task_delete(\n        branch_number: int,\n        filter_fn: Callable,\n        hash_reduce_left: int,\n        db_root: str,\n        class_model: T,\n    ) -&gt; int:\n        \"\"\"Task for find and delete documents.\n\n        This method is for internal use.\n\n        Returns:\n            The number of deleted documents.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: Path = Path(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        counter: int = 0\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            new_state: dict[str, str] = {}\n            for key, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    counter -= 1\n                else:\n                    new_state[key] = val\n            await leaf_path.write_bytes(orjson.dumps(new_state))\n        return counter\n\n    async def delete_many(\n        self,\n        filter_fn: Callable,\n        max_workers: int | None = None,\n    ) -&gt; int:\n        \"\"\"Delete one or more documents matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            The number of deleted documents.\n        \"\"\"\n        branch_numbers: range = range(1, self._max_branch_number)\n        search_task_fn: Callable = self._task_delete\n        hash_reduce_left: int = self._hash_reduce_left\n        db_root: str = self._db_root\n        class_model: T = self._class_model\n        counter: int = 0\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                counter += await future.result()\n        if counter &lt; 0:\n            await self._counter_documents(counter)\n        return abs(counter)\n</code></pre>"},{"location":"pages/mixins/delete/#scruby.mixins.delete.Delete.delete_many","title":"<code>delete_many(filter_fn, max_workers=None)</code>  <code>async</code>","text":"<p>Delete one or more documents matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of deleted documents.</p> Source code in <code>src/scruby/mixins/delete.py</code> <pre><code>async def delete_many(\n    self,\n    filter_fn: Callable,\n    max_workers: int | None = None,\n) -&gt; int:\n    \"\"\"Delete one or more documents matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        The number of deleted documents.\n    \"\"\"\n    branch_numbers: range = range(1, self._max_branch_number)\n    search_task_fn: Callable = self._task_delete\n    hash_reduce_left: int = self._hash_reduce_left\n    db_root: str = self._db_root\n    class_model: T = self._class_model\n    counter: int = 0\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            counter += await future.result()\n    if counter &lt; 0:\n        await self._counter_documents(counter)\n    return abs(counter)\n</code></pre>"},{"location":"pages/mixins/find/","title":"Find","text":"<p>Quantum methods for searching documents.</p>"},{"location":"pages/mixins/find/#scruby.mixins.find.Find","title":"<code>Find</code>","text":"<p>Quantum methods for searching documents.</p> Source code in <code>src/scruby/mixins/find.py</code> <pre><code>class Find[T]:\n    \"\"\"Quantum methods for searching documents.\"\"\"\n\n    @staticmethod\n    async def _task_find(\n        branch_number: int,\n        filter_fn: Callable,\n        hash_reduce_left: str,\n        db_root: str,\n        class_model: T,\n    ) -&gt; list[T] | None:\n        \"\"\"Task for find documents.\n\n        This method is for internal use.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: Path = Path(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        docs: list[T] = []\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            for _, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    docs.append(doc)\n        return docs or None\n\n    async def find_one(\n        self,\n        filter_fn: Callable,\n        max_workers: int | None = None,\n    ) -&gt; T | None:\n        \"\"\"Finds a single document matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            Document or None.\n        \"\"\"\n        branch_numbers: range = range(1, self._max_branch_number)\n        search_task_fn: Callable = self._task_find\n        hash_reduce_left: int = self._hash_reduce_left\n        db_root: str = self._db_root\n        class_model: T = self._class_model\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                docs = await future.result()\n                if docs is not None:\n                    return docs[0]\n        return None\n\n    async def find_many(\n        self,\n        filter_fn: Callable,\n        limit_docs: int = 1000,\n        max_workers: int | None = None,\n    ) -&gt; list[T] | None:\n        \"\"\"Finds one or more documents matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            limit_docs: Limiting the number of documents. By default = 1000.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        branch_numbers: range = range(1, self._max_branch_number)\n        search_task_fn: Callable = self._task_find\n        hash_reduce_left: int = self._hash_reduce_left\n        db_root: str = self._db_root\n        class_model: T = self._class_model\n        counter: int = 0\n        result: list[T] = []\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                if counter &gt;= limit_docs:\n                    return result[:limit_docs]\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                docs = await future.result()\n                if docs is not None:\n                    for doc in docs:\n                        if counter &gt;= limit_docs:\n                            return result[:limit_docs]\n                        result.append(doc)\n                        counter += 1\n        return result or None\n</code></pre>"},{"location":"pages/mixins/find/#scruby.mixins.find.Find.find_many","title":"<code>find_many(filter_fn, limit_docs=1000, max_workers=None)</code>  <code>async</code>","text":"<p>Finds one or more documents matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>limit_docs</code> <code>int</code> <p>Limiting the number of documents. By default = 1000.</p> <code>1000</code> <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> required <p>Returns:</p> Type Description <code>list[T] | None</code> <p>List of documents or None.</p> Source code in <code>src/scruby/mixins/find.py</code> <pre><code>async def find_many(\n    self,\n    filter_fn: Callable,\n    limit_docs: int = 1000,\n    max_workers: int | None = None,\n) -&gt; list[T] | None:\n    \"\"\"Finds one or more documents matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        limit_docs: Limiting the number of documents. By default = 1000.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        List of documents or None.\n    \"\"\"\n    branch_numbers: range = range(1, self._max_branch_number)\n    search_task_fn: Callable = self._task_find\n    hash_reduce_left: int = self._hash_reduce_left\n    db_root: str = self._db_root\n    class_model: T = self._class_model\n    counter: int = 0\n    result: list[T] = []\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            if counter &gt;= limit_docs:\n                return result[:limit_docs]\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            if docs is not None:\n                for doc in docs:\n                    if counter &gt;= limit_docs:\n                        return result[:limit_docs]\n                    result.append(doc)\n                    counter += 1\n    return result or None\n</code></pre>"},{"location":"pages/mixins/find/#scruby.mixins.find.Find.find_one","title":"<code>find_one(filter_fn, max_workers=None)</code>  <code>async</code>","text":"<p>Finds a single document matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Document or None.</p> Source code in <code>src/scruby/mixins/find.py</code> <pre><code>async def find_one(\n    self,\n    filter_fn: Callable,\n    max_workers: int | None = None,\n) -&gt; T | None:\n    \"\"\"Finds a single document matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        Document or None.\n    \"\"\"\n    branch_numbers: range = range(1, self._max_branch_number)\n    search_task_fn: Callable = self._task_find\n    hash_reduce_left: int = self._hash_reduce_left\n    db_root: str = self._db_root\n    class_model: T = self._class_model\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            if docs is not None:\n                return docs[0]\n    return None\n</code></pre>"},{"location":"pages/mixins/keys/","title":"Keys","text":"<p>Methods for working with keys.</p>"},{"location":"pages/mixins/keys/#scruby.mixins.keys.Keys","title":"<code>Keys</code>","text":"<p>Methods for working with keys.</p> Source code in <code>src/scruby/mixins/keys.py</code> <pre><code>class Keys[T]:\n    \"\"\"Methods for working with keys.\"\"\"\n\n    async def add_key(\n        self,\n        key: str,\n        value: T,\n    ) -&gt; None:\n        \"\"\"Asynchronous method for adding key to collection.\n\n        Args:\n            key: Key name. Type `str`.\n            value: Value of key. Type `BaseModel`.\n\n        Returns:\n            None.\n        \"\"\"\n        # The path to cell of collection.\n        leaf_path: Path = await self._get_leaf_path(key)\n        value_json: str = value.model_dump_json()\n        # Write key-value to collection.\n        if await leaf_path.exists():\n            # Add new key.\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n            except KeyError:\n                data[key] = value_json\n                await leaf_path.write_bytes(orjson.dumps(data))\n            else:\n                err = KeyAlreadyExistsError()\n                logger.error(err.message)\n                raise err\n        else:\n            # Add new key to a blank leaf.\n            await leaf_path.write_bytes(orjson.dumps({key: value_json}))\n        await self._counter_documents(1)\n\n    async def update_key(\n        self,\n        key: str,\n        value: T,\n    ) -&gt; None:\n        \"\"\"Asynchronous method for updating key to collection.\n\n        Args:\n            key: Key name. Type `str`.\n            value: Value of key. Type `BaseModel`.\n\n        Returns:\n            None.\n        \"\"\"\n        # The path to cell of collection.\n        leaf_path: Path = await self._get_leaf_path(key)\n        value_json: str = value.model_dump_json()\n        # Update the existing key.\n        if await leaf_path.exists():\n            # Update the existing key.\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n                data[key] = value_json\n                await leaf_path.write_bytes(orjson.dumps(data))\n            except KeyError:\n                err = KeyNotExistsError()\n                logger.error(err.message)\n                raise err from None\n        else:\n            logger.error(\"The key not exists.\")\n            raise KeyError()\n\n    async def get_key(self, key: str) -&gt; T:\n        \"\"\"Asynchronous method for getting value of key from collection.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            Value of key or KeyError.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self._get_leaf_path(key)\n        # Get value of key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            obj: T = self._class_model.model_validate_json(data[key])\n            return obj\n        msg: str = \"`get_key` - The unacceptable key value.\"\n        logger.error(msg)\n        raise KeyError()\n\n    async def has_key(self, key: str) -&gt; bool:\n        \"\"\"Asynchronous method for checking presence of key in collection.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            True, if the key is present.\n        \"\"\"\n        # Get path to cell of collection.\n        leaf_path: Path = await self._get_leaf_path(key)\n        # Checking whether there is a key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n                return True\n            except KeyError:\n                return False\n        return False\n\n    async def delete_key(self, key: str) -&gt; None:\n        \"\"\"Asynchronous method for deleting key from collection.\n\n        Args:\n            key: Key name.\n\n        Returns:\n            None.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self._get_leaf_path(key)\n        # Deleting key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            del data[key]\n            await leaf_path.write_bytes(orjson.dumps(data))\n            await self._counter_documents(-1)\n            return\n        msg: str = \"`delete_key` - The unacceptable key value.\"\n        logger.error(msg)\n        raise KeyError()\n</code></pre>"},{"location":"pages/mixins/keys/#scruby.mixins.keys.Keys.add_key","title":"<code>add_key(key, value)</code>  <code>async</code>","text":"<p>Asynchronous method for adding key to collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name. Type <code>str</code>.</p> required <code>value</code> <code>T</code> <p>Value of key. Type <code>BaseModel</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/scruby/mixins/keys.py</code> <pre><code>async def add_key(\n    self,\n    key: str,\n    value: T,\n) -&gt; None:\n    \"\"\"Asynchronous method for adding key to collection.\n\n    Args:\n        key: Key name. Type `str`.\n        value: Value of key. Type `BaseModel`.\n\n    Returns:\n        None.\n    \"\"\"\n    # The path to cell of collection.\n    leaf_path: Path = await self._get_leaf_path(key)\n    value_json: str = value.model_dump_json()\n    # Write key-value to collection.\n    if await leaf_path.exists():\n        # Add new key.\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n        except KeyError:\n            data[key] = value_json\n            await leaf_path.write_bytes(orjson.dumps(data))\n        else:\n            err = KeyAlreadyExistsError()\n            logger.error(err.message)\n            raise err\n    else:\n        # Add new key to a blank leaf.\n        await leaf_path.write_bytes(orjson.dumps({key: value_json}))\n    await self._counter_documents(1)\n</code></pre>"},{"location":"pages/mixins/keys/#scruby.mixins.keys.Keys.delete_key","title":"<code>delete_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for deleting key from collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/scruby/mixins/keys.py</code> <pre><code>async def delete_key(self, key: str) -&gt; None:\n    \"\"\"Asynchronous method for deleting key from collection.\n\n    Args:\n        key: Key name.\n\n    Returns:\n        None.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self._get_leaf_path(key)\n    # Deleting key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        del data[key]\n        await leaf_path.write_bytes(orjson.dumps(data))\n        await self._counter_documents(-1)\n        return\n    msg: str = \"`delete_key` - The unacceptable key value.\"\n    logger.error(msg)\n    raise KeyError()\n</code></pre>"},{"location":"pages/mixins/keys/#scruby.mixins.keys.Keys.get_key","title":"<code>get_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for getting value of key from collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>T</code> <p>Value of key or KeyError.</p> Source code in <code>src/scruby/mixins/keys.py</code> <pre><code>async def get_key(self, key: str) -&gt; T:\n    \"\"\"Asynchronous method for getting value of key from collection.\n\n    Args:\n        key: Key name.\n\n    Returns:\n        Value of key or KeyError.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self._get_leaf_path(key)\n    # Get value of key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        obj: T = self._class_model.model_validate_json(data[key])\n        return obj\n    msg: str = \"`get_key` - The unacceptable key value.\"\n    logger.error(msg)\n    raise KeyError()\n</code></pre>"},{"location":"pages/mixins/keys/#scruby.mixins.keys.Keys.has_key","title":"<code>has_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for checking presence of key in collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True, if the key is present.</p> Source code in <code>src/scruby/mixins/keys.py</code> <pre><code>async def has_key(self, key: str) -&gt; bool:\n    \"\"\"Asynchronous method for checking presence of key in collection.\n\n    Args:\n        key: Key name.\n\n    Returns:\n        True, if the key is present.\n    \"\"\"\n    # Get path to cell of collection.\n    leaf_path: Path = await self._get_leaf_path(key)\n    # Checking whether there is a key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n            return True\n        except KeyError:\n            return False\n    return False\n</code></pre>"},{"location":"pages/mixins/keys/#scruby.mixins.keys.Keys.update_key","title":"<code>update_key(key, value)</code>  <code>async</code>","text":"<p>Asynchronous method for updating key to collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name. Type <code>str</code>.</p> required <code>value</code> <code>T</code> <p>Value of key. Type <code>BaseModel</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/scruby/mixins/keys.py</code> <pre><code>async def update_key(\n    self,\n    key: str,\n    value: T,\n) -&gt; None:\n    \"\"\"Asynchronous method for updating key to collection.\n\n    Args:\n        key: Key name. Type `str`.\n        value: Value of key. Type `BaseModel`.\n\n    Returns:\n        None.\n    \"\"\"\n    # The path to cell of collection.\n    leaf_path: Path = await self._get_leaf_path(key)\n    value_json: str = value.model_dump_json()\n    # Update the existing key.\n    if await leaf_path.exists():\n        # Update the existing key.\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n            data[key] = value_json\n            await leaf_path.write_bytes(orjson.dumps(data))\n        except KeyError:\n            err = KeyNotExistsError()\n            logger.error(err.message)\n            raise err from None\n    else:\n        logger.error(\"The key not exists.\")\n        raise KeyError()\n</code></pre>"},{"location":"pages/mixins/update/","title":"Update","text":"<p>Methods for updating documents.</p>"},{"location":"pages/mixins/update/#scruby.mixins.update.Update","title":"<code>Update</code>","text":"<p>Methods for updating documents.</p> Source code in <code>src/scruby/mixins/update.py</code> <pre><code>class Update[T]:\n    \"\"\"Methods for updating documents.\"\"\"\n\n    @staticmethod\n    async def _task_update(\n        branch_number: int,\n        filter_fn: Callable,\n        hash_reduce_left: str,\n        db_root: str,\n        class_model: T,\n        new_data: dict[str, Any],\n    ) -&gt; int:\n        \"\"\"Task for find documents.\n\n        This method is for internal use.\n\n        Returns:\n            The number of updated documents.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: Path = Path(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        counter: int = 0\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            new_state: dict[str, str] = {}\n            for _, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    for key, value in new_data.items():\n                        doc.__dict__[key] = value\n                        new_state[key] = doc.model_dump_json()\n                    counter += 1\n            await leaf_path.write_bytes(orjson.dumps(new_state))\n        return counter\n\n    async def update_many(\n        self,\n        filter_fn: Callable,\n        new_data: dict[str, Any],\n        max_workers: int | None = None,\n    ) -&gt; int:\n        \"\"\"Updates one or more documents matching the filter.\n\n        The search is based on the effect of a quantum loop.\n        The search effectiveness depends on the number of processor threads.\n        Ideally, hundreds and even thousands of threads are required.\n\n        Args:\n            filter_fn: A function that execute the conditions of filtering.\n            new_data: New data for the fields that need to be updated.\n            max_workers: The maximum number of processes that can be used to\n                         execute the given calls. If None or not given then as many\n                         worker processes will be created as the machine has processors.\n            timeout: The number of seconds to wait for the result if the future isn't done.\n                     If None, then there is no limit on the wait time.\n\n        Returns:\n            The number of updated documents.\n        \"\"\"\n        branch_numbers: range = range(1, self._max_branch_number)\n        update_task_fn: Callable = self._task_update\n        hash_reduce_left: int = self._hash_reduce_left\n        db_root: str = self._db_root\n        class_model: T = self._class_model\n        counter: int = 0\n        with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    update_task_fn,\n                    branch_number,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                    new_data,\n                )\n                counter += await future.result()\n        return counter\n</code></pre>"},{"location":"pages/mixins/update/#scruby.mixins.update.Update.update_many","title":"<code>update_many(filter_fn, new_data, max_workers=None)</code>  <code>async</code>","text":"<p>Updates one or more documents matching the filter.</p> <p>The search is based on the effect of a quantum loop. The search effectiveness depends on the number of processor threads. Ideally, hundreds and even thousands of threads are required.</p> <p>Parameters:</p> Name Type Description Default <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> required <code>new_data</code> <code>dict[str, Any]</code> <p>New data for the fields that need to be updated.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <p>The number of seconds to wait for the result if the future isn't done.      If None, then there is no limit on the wait time.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of updated documents.</p> Source code in <code>src/scruby/mixins/update.py</code> <pre><code>async def update_many(\n    self,\n    filter_fn: Callable,\n    new_data: dict[str, Any],\n    max_workers: int | None = None,\n) -&gt; int:\n    \"\"\"Updates one or more documents matching the filter.\n\n    The search is based on the effect of a quantum loop.\n    The search effectiveness depends on the number of processor threads.\n    Ideally, hundreds and even thousands of threads are required.\n\n    Args:\n        filter_fn: A function that execute the conditions of filtering.\n        new_data: New data for the fields that need to be updated.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The number of seconds to wait for the result if the future isn't done.\n                 If None, then there is no limit on the wait time.\n\n    Returns:\n        The number of updated documents.\n    \"\"\"\n    branch_numbers: range = range(1, self._max_branch_number)\n    update_task_fn: Callable = self._task_update\n    hash_reduce_left: int = self._hash_reduce_left\n    db_root: str = self._db_root\n    class_model: T = self._class_model\n    counter: int = 0\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                update_task_fn,\n                branch_number,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n                new_data,\n            )\n            counter += await future.result()\n    return counter\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"<p>Example collection of how to use a database.</p>"},{"location":"pages/usage/aggregation/","title":"Aggregation classes","text":""},{"location":"pages/usage/aggregation/#average","title":"Average","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the average value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom decimal import ROUND_HALF_EVEN\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Average\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def task_calculate_average(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; float:\n    \"\"\"Custom task.\n\n    Calculate the average value.\n    \"\"\"\n    max_workers: int | None = None\n    average_age = Average(\n        precision=\".00\",           # by default = .00\n        rounding=ROUND_HALF_EVEN,  # by default = ROUND_HALF_EVEN\n    )\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            for doc in docs:\n                average_age.set(doc.age)\n    return float(average_age.get())\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = await user_coll.run_custom_task(task_calculate_average)\n    print(result)  # =&gt; 50.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#counter","title":"Counter","text":"main.py<pre><code>\"\"\"Aggregation class for calculating sum of values.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Counter\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def task_counter(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; list[User]:\n    \"\"\"Custom task.\n\n    This task implements a counter of documents.\n    \"\"\"\n    max_workers: int | None = None\n    users: list[User] = []\n    counter = Counter(limit=limit_docs)  # `limit` by default = 1000\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            for doc in docs:\n                if counter.check():\n                    # [:limit_docs] - Control overflow in a multithreaded environment.\n                    return users[:limit_docs]\n                users.append(doc)\n                counter.next()\n    return users\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = await user_coll.run_custom_task(\n        custom_task_fn=task_counter,\n        limit_docs=5,\n    )\n    print(len(result))  # =&gt; 5\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#max","title":"Max","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the maximum value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Max\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def task_calculate_max(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the max value.\n    \"\"\"\n    max_workers: int | None = None\n    max_age = Max()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            for doc in docs:\n                max_age.set(doc.age)\n    return max_age.get()\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = await user_coll.run_custom_task(task_calculate_max)\n    print(result)  # =&gt; 90.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#min","title":"Min","text":"main.py<pre><code>\"\"\"Aggregation class for calculating the minimum value.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Min\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def task_calculate_min(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the min value.\n    \"\"\"\n    max_workers: int | None = None\n    min_age = Min()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            for doc in docs:\n                min_age.set(doc.age)\n    return min_age.get()\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = await user_coll.run_custom_task(task_calculate_min)\n    print(result)  # =&gt; 10.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/aggregation/#sum","title":"Sum","text":"main.py<pre><code>\"\"\"Aggregation class for calculating sum of values.\"\"\"\n\nimport anyio\nimport concurrent.futures\nfrom collections.abc import Callable\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\n\nfrom scruby import Scruby, constants\nfrom scruby.aggregation import Sum\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    first_name: str\n    age: int\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def task_calculate_sum(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n    limit_docs: int,\n) -&gt; int:\n    \"\"\"Custom task.\n\n    Calculate the sum of values.\n    \"\"\"\n    max_workers: int | None = None\n    sum_age = Sum()\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            for doc in docs:\n                sum_age.set(doc.age)\n    return int(sum_age.get())\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = await user_coll.run_custom_task(task_calculate_sum)\n    print(result)  # =&gt; 450.0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/count_documents/","title":"Count documents","text":""},{"location":"pages/usage/count_documents/#get-an-estimate-of-number-of-documents-using-collection-metadata","title":"Get an estimate of number of documents using collection metadata","text":"main.py<pre><code>\"\"\"Get an estimate of the number of documents in this collection using collection metadata.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    print(await user_coll.estimated_document_count())  # =&gt; 0\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n    print(await user_coll.estimated_document_count())  # =&gt; 1\n\n    # Delete user from collection.\n    await user_coll.delete_key(\"+447986123456\")\n    print(await user_coll.estimated_document_count())  # =&gt; 0\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/count_documents/#count-number-of-documents-in-collection","title":"Count number of documents in collection","text":"main.py<pre><code>\"\"\"Count the number of documents a matching the filter in this collection.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await db.set_key(f\"+44798612345{num}\", user)\n\n    result: int = await user_coll.count_documents(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    print(result:)  # =&gt; 2\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/custom_task/","title":"Custom task","text":""},{"location":"pages/usage/custom_task/#custom-task","title":"Custom task","text":"main.py<pre><code>\"\"\"Running custom task.\n\nThis method running a task created on the basis of a quantum loop.\nEffectiveness running task depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nimport concurrent.futures\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def custom_task(\n    get_docs_fn: Callable,\n    branch_numbers: range,\n    hash_reduce_left: int,\n    db_root: str,\n    class_model: Any,\n) -&gt; Any:\n    \"\"\"Custom task.\n\n    Calculate the number of users named John.\n    \"\"\"\n    max_workers: int | None = None\n    counter: int = 0\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                get_docs_fn,\n                branch_number,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            for doc in docs:\n                if doc.first_name == \"John\":\n                    counter += 1\n    return counter\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    result = await user_coll.run_custom_task(custom_task)\n    print(result)  # =&gt; 9\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_collection/","title":"Delete collection","text":""},{"location":"pages/usage/delete_collection/#delete-collection","title":"Delete Collection","text":"main.py<pre><code>\"\"\"Delete collection.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    collection_list = await Scruby.collection_list()\n    print(ucollection_list)  # [\"User\"]\n\n    await Scruby.delete_collection(\"User\")\n\n    collection_list = await Scruby.collection_list()\n    print(ucollection_list)  # []\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_documents/","title":"Delete documents","text":""},{"location":"pages/usage/delete_documents/#find-a-single-document-and-delete","title":"Find a single document and delete","text":"main.py<pre><code>\"\"\"Find a single document, matching the filter and delete it.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Find user by email.\n    user_details: User | None = user_coll.find_one(\n        filter_fn=lambda doc: doc.email == \"John_Smith@gmail.com\",\n    )\n    # Delete user from collection.\n    await user_coll.delete_key(user_details.phone)\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/delete_documents/#find-one-or-more-documents-and-deletes","title":"Find one or more documents and deletes","text":"main.py<pre><code>\"\"\"Delete one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(f\"+44798612345{num}\", user)\n\n    amount_of_deleted: int = await user_coll.delete_many(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    print(amount_of_deleted)  # =&gt; 2\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/find_a_single_document/","title":"Find a single document","text":""},{"location":"pages/usage/find_a_single_document/#find-a-single-document-matching-the-filter","title":"Find a single document matching the filter","text":"main.py<pre><code>\"\"\"Find a single document matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\nfrom pprint import pprint as pp\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Find user by email.\n    user_details: User | None = await user_coll.find_one(\n        filter_fn=lambda doc: doc.email == \"John_Smith@gmail.com\",\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Find user by birthday.\n    user_details: User | None = await user_coll.find_one(\n        filter_fn=lambda doc: doc.birthday == datetime.datetime(1970, 1, 1),\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/find_documents/","title":"Find documents","text":""},{"location":"pages/usage/find_documents/#find-one-or-more-documents-matching-the-filter","title":"Find one or more documents matching the filter","text":"main.py<pre><code>\"\"\"Find one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\nfrom pprint import pprint as pp\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            last_name=\"Smith\",\n            birthday=datetime.datetime(1970, 1, num),\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    # Find users by email.\n    users: list[User] | None = await user_coll.find_many(\n        filter_fn=lambda doc: doc.email == \"John_Smith_5@gmail.com\" or doc.email == \"John_Smith_8@gmail.com\",\n    )\n    if users is not None:\n        pp(users)\n    else:\n        print(\"No users!\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/get_collection_list/","title":"Get collection list","text":""},{"location":"pages/usage/get_collection_list/#get-collection-list","title":"Get collection list","text":"main.py<pre><code>\"\"\"Get collection list.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    collection_list = await Scruby.collection_list()\n    print(ucollection_list)  # [\"User\"]\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/get_collection_name/","title":"Get collection name","text":""},{"location":"pages/usage/get_collection_name/#get-collection-name","title":"Get collection name","text":"main.py<pre><code>\"\"\"Get collection name.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    print(user_coll.collection_name())  # \"User\"\n    print(user_coll.collection_full_name())  # \"ScrubyDB/User\"\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/update_documents/","title":"Update documents","text":""},{"location":"pages/usage/update_documents/#update-documents","title":"Update documents","text":"main.py<pre><code>\"\"\"Update one or more documents matching the filter.\n\nThe search is based on the effect of a quantum loop.\nThe search effectiveness depends on the number of processor threads.\nIdeally, hundreds and even thousands of threads are required.\n\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\nconstants.HASH_REDUCE_LEFT = 6  # By default = 6\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create users.\n    for num in range(1, 10):\n        user = User(\n            first_name=\"John\",\n            age=f\"{num * 10}\",\n            email=f\"John_Smith_{num}@gmail.com\",\n            phone=f\"+44798612345{num}\",\n        )\n        await user_coll.add_key(user.phone, user)\n\n    number_updated_users = await user_coll.update_many(\n        filter_fn=lambda _: True,  # Update all documents.\n        new_data={\"first_name\": \"Georg\"},\n    )\n    print(number_updated_users)  # =&gt; 9\n\n    users: list[User] | None = await user_coll.find_many(\n        filter_fn=lambda _: True,  # Find all documents\n    )\n    for user in users:\n        print(user.first_name)  # =&gt; Georg\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"pages/usage/working_with_keys/","title":"Working with keys","text":""},{"location":"pages/usage/working_with_keys/#working-with-keys","title":"Working with keys","text":"main.py<pre><code>\"\"\"Working with keys.\"\"\"\n\nimport anyio\nimport datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber, PhoneNumberValidator\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: Annotated[PhoneNumber, PhoneNumberValidator(number_format=\"E164\")]\n\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = await Scruby.create(User)\n\n    # Create user.\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    # Add data of user to collection.\n    await user_coll.add_key(user.phone, user)\n\n    # Update data of  user to collection.\n    await user_coll.update_key(user.phone, user)\n\n    # Get user from collection.\n    await user_coll.get_key(\"+447986123456\")  # =&gt; user\n    await user_coll.get_key(\"key missing\")  # =&gt; KeyError\n\n    await user_coll.has_key(\"+447986123456\")  # =&gt; True\n    await user_coll.has_key(\"key missing\")  # =&gt; False\n\n    await user_coll.delete_key(\"+447986123456\")\n    await user_coll.delete_key(\"+447986123456\")  # =&gt; KeyError\n    await user_coll.delete_key(\"key missing\")  # =&gt; KeyError\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"}]}