{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scruby","text":"<p> A fast key-value storage library. <p> </p> <p>       Scruby is a fast key-value storage asynchronous library that provides an       ordered mapping from string keys to string values.       The library uses fractal-tree addressing.               The database consists of collections.       The maximum size of the one collection is 16\\*\\*8=4294967296 branches,       each branch can store one or more keys.               The value of any key in collection can be obtained in 8 steps,       thereby achieving high performance.               In the future, to search by value of key, the use of a quantum loop is supposed.     </p> </p> <p></p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/constants/","title":"Constants","text":"<p>Constant variables.</p> <p>The module contains the following variables:</p> <ul> <li><code>DB_ROOT</code> - Path to root directory of database. By default = \"ScrubyDB\" (in root of project).</li> <li><code>LENGTH_SEPARATED_HASH</code> - Length of separated hash for create path inside collection.</li> </ul>"},{"location":"pages/db/","title":"Details","text":"<p>Creation and management of the database.</p>"},{"location":"pages/db/#scruby.db.Scruby","title":"<code>Scruby</code>","text":"<p>Creation and management of database.</p> <p>Parameters:</p> Name Type Description Default <code>class_model</code> <code>Scruby[T]</code> <p>Class of Model (Pydantic).</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>class Scruby[T]:\n    \"\"\"Creation and management of database.\n\n    Args:\n        class_model: Class of Model (Pydantic).\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        class_model: T,\n    ) -&gt; None:\n        self.__class_model = class_model\n\n    async def get_leaf_path(self, key: str) -&gt; Path:\n        \"\"\"Asynchronous method for getting path to collection cell by key.\n\n        Args:\n            key: Key name.\n        \"\"\"\n        if not isinstance(key, str):\n            raise KeyError(\"The key is not a type of `str`.\")\n        if len(key) == 0:\n            raise KeyError(\"The key should not be empty.\")\n        # Get length of hash.\n        length_hash = constants.LENGTH_SEPARATED_HASH\n        # Key to crc32 sum.\n        key_as_hash: str = f\"{zlib.crc32(key.encode('utf-8')):08x}\"[0:length_hash]\n        # Convert crc32 sum in the segment of path.\n        separated_hash: str = \"/\".join(list(key_as_hash))\n        # The path of the branch to the database.\n        branch_path: Path = Path(\n            *(\n                constants.DB_ROOT,\n                self.__class_model.__name__,\n                separated_hash,\n            ),\n        )\n        # If the branch does not exist, need to create it.\n        if not await branch_path.exists():\n            await branch_path.mkdir(parents=True)\n        # The path to the database cell.\n        leaf_path: Path = Path(*(branch_path, \"leaf.json\"))\n        return leaf_path\n\n    async def set_key(\n        self,\n        key: str,\n        value: T,\n    ) -&gt; None:\n        \"\"\"Asynchronous method for adding and updating keys to collection.\n\n        Args:\n            key: Key name.\n            value: Value of key.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self.get_leaf_path(key)\n        value_json: str = value.model_dump_json()\n        # Write key-value to the database.\n        if await leaf_path.exists():\n            # Add new key or update existing.\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            data[key] = value_json\n            await leaf_path.write_bytes(orjson.dumps(data))\n        else:\n            # Add new key to a blank leaf.\n            await leaf_path.write_bytes(orjson.dumps({key: value_json}))\n\n    async def get_key(self, key: str) -&gt; T:\n        \"\"\"Asynchronous method for getting value of key from collection.\n\n        Args:\n            key: Key name.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self.get_leaf_path(key)\n        # Get value of key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            obj: T = self.__class_model.model_validate_json(data[key])\n            return obj\n        raise KeyError()\n\n    async def has_key(self, key: str) -&gt; bool:\n        \"\"\"Asynchronous method for checking presence of key in collection.\n\n        Args:\n            key: Key name.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self.get_leaf_path(key)\n        # Checking whether there is a key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            try:\n                data[key]\n                return True\n            except KeyError:\n                return False\n        return False\n\n    async def delete_key(self, key: str) -&gt; None:\n        \"\"\"Asynchronous method for deleting key from collection.\n\n        Args:\n            key: Key name.\n        \"\"\"\n        # The path to the database cell.\n        leaf_path: Path = await self.get_leaf_path(key)\n        # Deleting key.\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict = orjson.loads(data_json) or {}\n            del data[key]\n            await leaf_path.write_bytes(orjson.dumps(data))\n            return\n        raise KeyError()\n\n    @classmethod\n    async def napalm(cls) -&gt; None:\n        \"\"\"Asynchronous method for full database deletion.\n\n        The main purpose is tests.\n\n        Warning:\n            - `Be careful, this will remove all keys.`\n        \"\"\"\n        with contextlib.suppress(FileNotFoundError):\n            await to_thread.run_sync(rmtree, constants.DB_ROOT)\n        return\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.delete_key","title":"<code>delete_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for deleting key from collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>async def delete_key(self, key: str) -&gt; None:\n    \"\"\"Asynchronous method for deleting key from collection.\n\n    Args:\n        key: Key name.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self.get_leaf_path(key)\n    # Deleting key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        del data[key]\n        await leaf_path.write_bytes(orjson.dumps(data))\n        return\n    raise KeyError()\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.get_key","title":"<code>get_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for getting value of key from collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>async def get_key(self, key: str) -&gt; T:\n    \"\"\"Asynchronous method for getting value of key from collection.\n\n    Args:\n        key: Key name.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self.get_leaf_path(key)\n    # Get value of key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        obj: T = self.__class_model.model_validate_json(data[key])\n        return obj\n    raise KeyError()\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.get_leaf_path","title":"<code>get_leaf_path(key)</code>  <code>async</code>","text":"<p>Asynchronous method for getting path to collection cell by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>async def get_leaf_path(self, key: str) -&gt; Path:\n    \"\"\"Asynchronous method for getting path to collection cell by key.\n\n    Args:\n        key: Key name.\n    \"\"\"\n    if not isinstance(key, str):\n        raise KeyError(\"The key is not a type of `str`.\")\n    if len(key) == 0:\n        raise KeyError(\"The key should not be empty.\")\n    # Get length of hash.\n    length_hash = constants.LENGTH_SEPARATED_HASH\n    # Key to crc32 sum.\n    key_as_hash: str = f\"{zlib.crc32(key.encode('utf-8')):08x}\"[0:length_hash]\n    # Convert crc32 sum in the segment of path.\n    separated_hash: str = \"/\".join(list(key_as_hash))\n    # The path of the branch to the database.\n    branch_path: Path = Path(\n        *(\n            constants.DB_ROOT,\n            self.__class_model.__name__,\n            separated_hash,\n        ),\n    )\n    # If the branch does not exist, need to create it.\n    if not await branch_path.exists():\n        await branch_path.mkdir(parents=True)\n    # The path to the database cell.\n    leaf_path: Path = Path(*(branch_path, \"leaf.json\"))\n    return leaf_path\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.has_key","title":"<code>has_key(key)</code>  <code>async</code>","text":"<p>Asynchronous method for checking presence of key in collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>async def has_key(self, key: str) -&gt; bool:\n    \"\"\"Asynchronous method for checking presence of key in collection.\n\n    Args:\n        key: Key name.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self.get_leaf_path(key)\n    # Checking whether there is a key.\n    if await leaf_path.exists():\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        try:\n            data[key]\n            return True\n        except KeyError:\n            return False\n    return False\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.napalm","title":"<code>napalm()</code>  <code>async</code> <code>classmethod</code>","text":"<p>Asynchronous method for full database deletion.</p> <p>The main purpose is tests.</p> Warning <ul> <li><code>Be careful, this will remove all keys.</code></li> </ul> Source code in <code>src\\scruby\\db.py</code> <pre><code>@classmethod\nasync def napalm(cls) -&gt; None:\n    \"\"\"Asynchronous method for full database deletion.\n\n    The main purpose is tests.\n\n    Warning:\n        - `Be careful, this will remove all keys.`\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        await to_thread.run_sync(rmtree, constants.DB_ROOT)\n    return\n</code></pre>"},{"location":"pages/db/#scruby.db.Scruby.set_key","title":"<code>set_key(key, value)</code>  <code>async</code>","text":"<p>Asynchronous method for adding and updating keys to collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <code>value</code> <code>Scruby[T]</code> <p>Value of key.</p> required Source code in <code>src\\scruby\\db.py</code> <pre><code>async def set_key(\n    self,\n    key: str,\n    value: T,\n) -&gt; None:\n    \"\"\"Asynchronous method for adding and updating keys to collection.\n\n    Args:\n        key: Key name.\n        value: Value of key.\n    \"\"\"\n    # The path to the database cell.\n    leaf_path: Path = await self.get_leaf_path(key)\n    value_json: str = value.model_dump_json()\n    # Write key-value to the database.\n    if await leaf_path.exists():\n        # Add new key or update existing.\n        data_json: bytes = await leaf_path.read_bytes()\n        data: dict = orjson.loads(data_json) or {}\n        data[key] = value_json\n        await leaf_path.write_bytes(orjson.dumps(data))\n    else:\n        # Add new key to a blank leaf.\n        await leaf_path.write_bytes(orjson.dumps({key: value_json}))\n</code></pre>"},{"location":"pages/installation/","title":"Installation","text":"<pre><code>uv add scruby\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"<pre><code>import anyio\nimport datetime\nfrom pydantic import BaseModel, EmailStr\nfrom pydantic_extra_types.phone_numbers import PhoneNumber\nfrom scruby import Scruby, constants\n\nconstants.DB_ROOT = \"ScrubyDB\"  # By default = \"ScrubyDB\"\n\nclass User(BaseModel):\n    \"\"\"Model of User.\"\"\"\n    first_name: str\n    last_name: str\n    birthday: datetime.datetime\n    email: EmailStr\n    phone: PhoneNumber\n\nasync def main() -&gt; None:\n    \"\"\"Example.\"\"\"\n    # Get collection of `User`.\n    user_coll = Scruby(User)\n\n    user = User(\n        first_name=\"John\",\n        last_name=\"Smith\",\n        birthday=datetime.datetime(1970, 1, 1),\n        email=\"John_Smith@gmail.com\",\n        phone=\"+447986123456\",\n    )\n\n    await user_coll.set_key(\"+447986123456\", user)\n\n    await user_coll.get_key(\"+447986123456\")  # =&gt; user\n    await user_coll.get_key(\"key missing\")  # =&gt; KeyError\n\n    await user_coll.has_key(\"+447986123456\")  # =&gt; True\n    await user_coll.has_key(\"key missing\")  # =&gt; False\n\n    await user_coll.delete_key(\"+447986123456\")\n    await user_coll.delete_key(\"+447986123456\")  # =&gt; KeyError\n    await user_coll.delete_key(\"key missing\")  # =&gt; KeyError\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    await Scruby.napalm()\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"}]}